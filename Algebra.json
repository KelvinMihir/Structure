[{
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 3011,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.annotated_decl" : "<Declaration>protocol Sequence<\/Declaration>",
        "key.bodylength" : 632,
        "key.bodyoffset" : 100,
        "key.doc.declaration" : "protocol Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a `for`-`in` loop:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s `contains(_:)` method, which every sequence inherits from `Sequence`, instead of iterating manually:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple `for`-`in` loops on a sequence will either resume iteration or restart from the beginning:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second `for`-`in` loop."
          },
          {
            "Para" : "To establish that a type you’ve created supports nondestructive iteration, add conformance to the `Collection` protocol."
          },
          {
            "Para" : "Making your own custom types conform to `Sequence` enables many useful operations, like `for`-`in` looping and the `contains` method, without much effort. To add `Sequence` conformance to your own custom type, add a `makeIterator()` method that returns an iterator."
          },
          {
            "Para" : "Alternatively, if your type can act as its own iterator, implementing the requirements of the `IteratorProtocol` protocol and declaring conformance to both `Sequence` and `IteratorProtocol` are sufficient."
          },
          {
            "Para" : "Here’s a definition of a `Countdown` sequence that serves as its own iterator. The `makeIterator()` method is provided as a default implementation."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A sequence should provide its iterator in O(1). The `Sequence` protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O() unless documented otherwise."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Sequence<\/Name><USR>s:ST<\/USR><Declaration>protocol Sequence<\/Declaration><CommentParts><Abstract><Para>A type that provides sequential, iterated access to its elements.<\/Para><\/Abstract><Discussion><Para>A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let oneTwoThree = 1...3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for number in oneTwoThree {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var hasMosquito = false]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for bug in bugs {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if bug == \"Mosquito\" {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        hasMosquito = true]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        break]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(\"'bugs' has a mosquito: \\(hasMosquito)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"'bugs' has a mosquito: false\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Sequence<\/codeVoice> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s <codeVoice>contains(_:)<\/codeVoice> method, which every sequence inherits from <codeVoice>Sequence<\/codeVoice>, instead of iterating manually:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if bugs.contains(\"Mosquito\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Break out the bug spray.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Whew, no mosquitos!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Whew, no mosquitos!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Repeated Access<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>The <codeVoice>Sequence<\/codeVoice> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loops on a sequence will either resume iteration or restart from the beginning:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if ... some condition { break }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ No defined behavior]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><Para>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <codeVoice>Collection<\/codeVoice> protocol.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Sequence Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Making your own custom types conform to <codeVoice>Sequence<\/codeVoice> enables many useful operations, like <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> looping and the <codeVoice>contains<\/codeVoice> method, without much effort. To add <codeVoice>Sequence<\/codeVoice> conformance to your own custom type, add a <codeVoice>makeIterator()<\/codeVoice> method that returns an iterator.<\/Para><Para>Alternatively, if your type can act as its own iterator, implementing the requirements of the <codeVoice>IteratorProtocol<\/codeVoice> protocol and declaring conformance to both <codeVoice>Sequence<\/codeVoice> and <codeVoice>IteratorProtocol<\/codeVoice> are sufficient.<\/Para><Para>Here’s a definition of a <codeVoice>Countdown<\/codeVoice> sequence that serves as its own iterator. The <codeVoice>makeIterator()<\/codeVoice> method is provided as a default implementation.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[struct Countdown: Sequence, IteratorProtocol {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    var count: Int]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    mutating func next() -> Int? {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        if count == 0 {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return nil]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        } else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            defer { count -= 1 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return count]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let threeToGo = Countdown(count: 3)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in threeToGo {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(i)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A sequence should provide its iterator in O(1). The <codeVoice>Sequence<\/codeVoice> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<emphasis>n<\/emphasis>) unless documented otherwise.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Sequence",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Sequence<\/decl.name><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 653,
        "key.modulename" : "Swift",
        "key.name" : "Sequence",
        "key.namelength" : 8,
        "key.nameoffset" : 90,
        "key.offset" : 80,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func accumulating(_ initial: <Type usr=\"s:ST7ElementQa\">Element<\/Type>, _ op: (<Type usr=\"s:ST7ElementQa\">Element<\/Type>, <Type usr=\"s:ST7ElementQa\">Element<\/Type>) -&gt; <Type usr=\"s:ST7ElementQa\">Element<\/Type>) -&gt; [<Type usr=\"s:ST7ElementQa\">Element<\/Type>]<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 409
              }
            ],
            "key.bodylength" : 200,
            "key.bodyoffset" : 530,
            "key.doc.column" : 17,
            "key.doc.comment" : "- Returns: Array of `Element` values starting with the given `initial`, followed by each\nelement combined with the accumulation with the given `op`.\n\n    let numbers = [1,2,3]\n    let accumulatedAdditionFrom10 = numbers.accumulating(10,+) \/\/ => [10,11,13]",
            "key.doc.declaration" : "public func accumulating(_ initial: Element, _ op: (Element, Element) -> Element) -> [Element]",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift\" line=\"16\" column=\"17\"><Name>accumulating(_:_:)<\/Name><USR>s:ST7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF<\/USR><Declaration>public func accumulating(_ initial: Element, _ op: (Element, Element) -&gt; Element) -&gt; [Element]<\/Declaration><CommentParts><ResultDiscussion><Para>Array of <codeVoice>Element<\/codeVoice> values starting with the given <codeVoice>initial<\/codeVoice>, followed by each element combined with the accumulation with the given <codeVoice>op<\/codeVoice>.<\/Para><Para>let numbers = [1,2,3] let accumulatedAdditionFrom10 = numbers.accumulating(10,+) \/\/ =&gt; [10,11,13]<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 16,
            "key.doc.name" : "accumulating(_:_:)",
            "key.doc.result_discussion" : [
              {
                "Para" : "Array of `Element` values starting with the given `initial`, followed by each element combined with the accumulation with the given `op`."
              },
              {
                "Para" : "let numbers = [1,2,3] let accumulatedAdditionFrom10 = numbers.accumulating(10,+) \/\/ => [10,11,13]"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 299,
            "key.docoffset" : 106,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>accumulating<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>initial<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>op<\/decl.var.parameter.name>: <decl.var.parameter.type>(<decl.var.parameter><decl.var.parameter.type><ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.type><ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype><\/decl.function.returntype><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype>[<ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype>]<\/decl.function.returntype><\/decl.function.method.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 315,
            "key.name" : "accumulating(_:_:)",
            "key.namelength" : 90,
            "key.nameoffset" : 421,
            "key.offset" : 416,
            "key.parsed_declaration" : "public func accumulating(\n    _ initial: Element,\n    _ op: (Element,Element) -> Element\n) -> [Element]",
            "key.parsed_scope.end" : 28,
            "key.parsed_scope.start" : 16,
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>var result: [<Type usr=\"s:ST4Selfxmfp\">Self<\/Type>.Element]<\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>result<\/decl.name>: <decl.var.type>[<ref.generic_type_param usr=\"s:ST4Selfxmfp\">Self<\/ref.generic_type_param>.Element]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 26,
                "key.name" : "result",
                "key.namelength" : 6,
                "key.nameoffset" : 543,
                "key.offset" : 539,
                "key.parsed_declaration" : "var result: [Element] = []",
                "key.parsed_scope.end" : 21,
                "key.parsed_scope.start" : 21,
                "key.typename" : "[Self.Element]",
                "key.typeusr" : "$SSay7ElementSTQzGD",
                "key.usr" : "s:ST7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF6resultL_AEvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var accum: <Type usr=\"s:ST4Selfxmfp\">Self<\/Type>.Element<\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>accum<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:ST4Selfxmfp\">Self<\/ref.generic_type_param>.Element<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 28,
                "key.name" : "accum",
                "key.namelength" : 5,
                "key.nameoffset" : 578,
                "key.offset" : 574,
                "key.parsed_declaration" : "var accum: Element = initial",
                "key.parsed_scope.end" : 22,
                "key.parsed_scope.start" : 22,
                "key.typename" : "Self.Element",
                "key.typeusr" : "$S7ElementSTQzD",
                "key.usr" : "s:ST7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF5accumL_ADvp"
              }
            ],
            "key.typename" : "<Self where Self : Sequence> (Self) -> (Self.Element, (Self.Element, Self.Element) -> Self.Element) -> [Self.Element]",
            "key.typeusr" : "$SySay7ElementQzGAB_A2B_ABtXEtcD",
            "key.usr" : "s:ST7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF"
          }
        ],
        "key.typename" : "Sequence.Protocol",
        "key.typeusr" : "$SST_pmD",
        "key.usr" : "s:ST"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Sequence<\/Declaration>",
        "key.bodylength" : 342,
        "key.bodyoffset" : 779,
        "key.doc.declaration" : "protocol Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a `for`-`in` loop:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s `contains(_:)` method, which every sequence inherits from `Sequence`, instead of iterating manually:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple `for`-`in` loops on a sequence will either resume iteration or restart from the beginning:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second `for`-`in` loop."
          },
          {
            "Para" : "To establish that a type you’ve created supports nondestructive iteration, add conformance to the `Collection` protocol."
          },
          {
            "Para" : "Making your own custom types conform to `Sequence` enables many useful operations, like `for`-`in` looping and the `contains` method, without much effort. To add `Sequence` conformance to your own custom type, add a `makeIterator()` method that returns an iterator."
          },
          {
            "Para" : "Alternatively, if your type can act as its own iterator, implementing the requirements of the `IteratorProtocol` protocol and declaring conformance to both `Sequence` and `IteratorProtocol` are sufficient."
          },
          {
            "Para" : "Here’s a definition of a `Countdown` sequence that serves as its own iterator. The `makeIterator()` method is provided as a default implementation."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A sequence should provide its iterator in O(1). The `Sequence` protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O() unless documented otherwise."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Sequence<\/Name><USR>s:ST<\/USR><Declaration>protocol Sequence<\/Declaration><CommentParts><Abstract><Para>A type that provides sequential, iterated access to its elements.<\/Para><\/Abstract><Discussion><Para>A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let oneTwoThree = 1...3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for number in oneTwoThree {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var hasMosquito = false]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for bug in bugs {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if bug == \"Mosquito\" {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        hasMosquito = true]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        break]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(\"'bugs' has a mosquito: \\(hasMosquito)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"'bugs' has a mosquito: false\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Sequence<\/codeVoice> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s <codeVoice>contains(_:)<\/codeVoice> method, which every sequence inherits from <codeVoice>Sequence<\/codeVoice>, instead of iterating manually:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if bugs.contains(\"Mosquito\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Break out the bug spray.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Whew, no mosquitos!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Whew, no mosquitos!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Repeated Access<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>The <codeVoice>Sequence<\/codeVoice> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loops on a sequence will either resume iteration or restart from the beginning:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if ... some condition { break }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ No defined behavior]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><Para>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <codeVoice>Collection<\/codeVoice> protocol.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Sequence Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Making your own custom types conform to <codeVoice>Sequence<\/codeVoice> enables many useful operations, like <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> looping and the <codeVoice>contains<\/codeVoice> method, without much effort. To add <codeVoice>Sequence<\/codeVoice> conformance to your own custom type, add a <codeVoice>makeIterator()<\/codeVoice> method that returns an iterator.<\/Para><Para>Alternatively, if your type can act as its own iterator, implementing the requirements of the <codeVoice>IteratorProtocol<\/codeVoice> protocol and declaring conformance to both <codeVoice>Sequence<\/codeVoice> and <codeVoice>IteratorProtocol<\/codeVoice> are sufficient.<\/Para><Para>Here’s a definition of a <codeVoice>Countdown<\/codeVoice> sequence that serves as its own iterator. The <codeVoice>makeIterator()<\/codeVoice> method is provided as a default implementation.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[struct Countdown: Sequence, IteratorProtocol {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    var count: Int]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    mutating func next() -> Int? {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        if count == 0 {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return nil]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        } else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            defer { count -= 1 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return count]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let threeToGo = Countdown(count: 3)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in threeToGo {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(i)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A sequence should provide its iterator in O(1). The <codeVoice>Sequence<\/codeVoice> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<emphasis>n<\/emphasis>) unless documented otherwise.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Sequence",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Sequence<\/decl.name><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 387,
        "key.modulename" : "Swift",
        "key.name" : "Sequence",
        "key.namelength" : 8,
        "key.nameoffset" : 745,
        "key.offset" : 735,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var accumulatingSum: [<Type usr=\"s:ST7ElementQa\">Element<\/Type>] { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1037
              }
            ],
            "key.bodylength" : 43,
            "key.bodyoffset" : 1076,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: Array of `Element` from `.zero`, applying `+` to each element contained herein\nand the accumulative value.\n\n    let numbers = [2,1,2]\n    let accumulated = numbers.accumulatingSum \/\/ => [0,2,3]",
            "key.doc.declaration" : "public var accumulatingSum: [Element] { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift\" line=\"39\" column=\"16\"><Name>accumulatingSum<\/Name><USR>s:ST7AlgebraAA8Additive7ElementRpzrlE15accumulatingSumSayADGvp<\/USR><Declaration>public var accumulatingSum: [Element] { get }<\/Declaration><CommentParts><ResultDiscussion><Para>Array of <codeVoice>Element<\/codeVoice> from <codeVoice>.zero<\/codeVoice>, applying <codeVoice>+<\/codeVoice> to each element contained herein and the accumulative value.<\/Para><Para>let numbers = [2,1,2] let accumulated = numbers.accumulatingSum \/\/ =&gt; [0,2,3]<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 39,
            "key.doc.name" : "accumulatingSum",
            "key.doc.result_discussion" : [
              {
                "Para" : "Array of `Element` from `.zero`, applying `+` to each element contained herein and the accumulative value."
              },
              {
                "Para" : "let numbers = [2,1,2] let accumulated = numbers.accumulatingSum \/\/ => [0,2,3]"
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 248,
            "key.docoffset" : 785,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>accumulatingSum<\/decl.name>: <decl.var.type>[<ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype>]<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 76,
            "key.name" : "accumulatingSum",
            "key.namelength" : 15,
            "key.nameoffset" : 1048,
            "key.offset" : 1044,
            "key.parsed_declaration" : "public var accumulatingSum: [Element]",
            "key.parsed_scope.end" : 41,
            "key.parsed_scope.start" : 39,
            "key.typename" : "[Self.Element]",
            "key.typeusr" : "$SSay7ElementSTQzGD",
            "key.usr" : "s:ST7AlgebraAA8Additive7ElementRpzrlE15accumulatingSumSayADGvp"
          }
        ],
        "key.typename" : "Sequence.Protocol",
        "key.typeusr" : "$SST_pmD",
        "key.usr" : "s:ST"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Sequence<\/Declaration>",
        "key.bodylength" : 348,
        "key.bodyoffset" : 1174,
        "key.doc.declaration" : "protocol Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a `for`-`in` loop:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s `contains(_:)` method, which every sequence inherits from `Sequence`, instead of iterating manually:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple `for`-`in` loops on a sequence will either resume iteration or restart from the beginning:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second `for`-`in` loop."
          },
          {
            "Para" : "To establish that a type you’ve created supports nondestructive iteration, add conformance to the `Collection` protocol."
          },
          {
            "Para" : "Making your own custom types conform to `Sequence` enables many useful operations, like `for`-`in` looping and the `contains` method, without much effort. To add `Sequence` conformance to your own custom type, add a `makeIterator()` method that returns an iterator."
          },
          {
            "Para" : "Alternatively, if your type can act as its own iterator, implementing the requirements of the `IteratorProtocol` protocol and declaring conformance to both `Sequence` and `IteratorProtocol` are sufficient."
          },
          {
            "Para" : "Here’s a definition of a `Countdown` sequence that serves as its own iterator. The `makeIterator()` method is provided as a default implementation."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A sequence should provide its iterator in O(1). The `Sequence` protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O() unless documented otherwise."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Sequence<\/Name><USR>s:ST<\/USR><Declaration>protocol Sequence<\/Declaration><CommentParts><Abstract><Para>A type that provides sequential, iterated access to its elements.<\/Para><\/Abstract><Discussion><Para>A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let oneTwoThree = 1...3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for number in oneTwoThree {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var hasMosquito = false]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for bug in bugs {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if bug == \"Mosquito\" {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        hasMosquito = true]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        break]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(\"'bugs' has a mosquito: \\(hasMosquito)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"'bugs' has a mosquito: false\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Sequence<\/codeVoice> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s <codeVoice>contains(_:)<\/codeVoice> method, which every sequence inherits from <codeVoice>Sequence<\/codeVoice>, instead of iterating manually:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if bugs.contains(\"Mosquito\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Break out the bug spray.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Whew, no mosquitos!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Whew, no mosquitos!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Repeated Access<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>The <codeVoice>Sequence<\/codeVoice> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loops on a sequence will either resume iteration or restart from the beginning:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if ... some condition { break }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ No defined behavior]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><Para>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <codeVoice>Collection<\/codeVoice> protocol.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Sequence Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Making your own custom types conform to <codeVoice>Sequence<\/codeVoice> enables many useful operations, like <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> looping and the <codeVoice>contains<\/codeVoice> method, without much effort. To add <codeVoice>Sequence<\/codeVoice> conformance to your own custom type, add a <codeVoice>makeIterator()<\/codeVoice> method that returns an iterator.<\/Para><Para>Alternatively, if your type can act as its own iterator, implementing the requirements of the <codeVoice>IteratorProtocol<\/codeVoice> protocol and declaring conformance to both <codeVoice>Sequence<\/codeVoice> and <codeVoice>IteratorProtocol<\/codeVoice> are sufficient.<\/Para><Para>Here’s a definition of a <codeVoice>Countdown<\/codeVoice> sequence that serves as its own iterator. The <codeVoice>makeIterator()<\/codeVoice> method is provided as a default implementation.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[struct Countdown: Sequence, IteratorProtocol {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    var count: Int]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    mutating func next() -> Int? {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        if count == 0 {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return nil]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        } else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            defer { count -= 1 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return count]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let threeToGo = Countdown(count: 3)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in threeToGo {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(i)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A sequence should provide its iterator in O(1). The <codeVoice>Sequence<\/codeVoice> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<emphasis>n<\/emphasis>) unless documented otherwise.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Sequence",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Sequence<\/decl.name><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 399,
        "key.modulename" : "Swift",
        "key.name" : "Sequence",
        "key.namelength" : 8,
        "key.nameoffset" : 1134,
        "key.offset" : 1124,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var accumulatingProduct: [<Type usr=\"s:ST7ElementQa\">Element<\/Type>] { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1435
              }
            ],
            "key.bodylength" : 42,
            "key.bodyoffset" : 1478,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: Array of `Element` from `.one`, applying `*` to each element contained herein\nand the accumulative value.\n\n    let numbers = [2,1,2]\n    let accumulated = numbers.accumulatingProduct \/\/ => [1,2,2]",
            "key.doc.declaration" : "public var accumulatingProduct: [Element] { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift\" line=\"52\" column=\"16\"><Name>accumulatingProduct<\/Name><USR>s:ST7AlgebraAA14Multiplicative7ElementRpzrlE19accumulatingProductSayADGvp<\/USR><Declaration>public var accumulatingProduct: [Element] { get }<\/Declaration><CommentParts><ResultDiscussion><Para>Array of <codeVoice>Element<\/codeVoice> from <codeVoice>.one<\/codeVoice>, applying <codeVoice>*<\/codeVoice> to each element contained herein and the accumulative value.<\/Para><Para>let numbers = [2,1,2] let accumulated = numbers.accumulatingProduct \/\/ =&gt; [1,2,2]<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 52,
            "key.doc.name" : "accumulatingProduct",
            "key.doc.result_discussion" : [
              {
                "Para" : "Array of `Element` from `.one`, applying `*` to each element contained herein and the accumulative value."
              },
              {
                "Para" : "let numbers = [2,1,2] let accumulated = numbers.accumulatingProduct \/\/ => [1,2,2]"
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 251,
            "key.docoffset" : 1180,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>accumulatingProduct<\/decl.name>: <decl.var.type>[<ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype>]<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 79,
            "key.name" : "accumulatingProduct",
            "key.namelength" : 19,
            "key.nameoffset" : 1446,
            "key.offset" : 1442,
            "key.parsed_declaration" : "public var accumulatingProduct: [Element]",
            "key.parsed_scope.end" : 54,
            "key.parsed_scope.start" : 52,
            "key.typename" : "[Self.Element]",
            "key.typeusr" : "$SSay7ElementSTQzGD",
            "key.usr" : "s:ST7AlgebraAA14Multiplicative7ElementRpzrlE19accumulatingProductSayADGvp"
          }
        ],
        "key.typename" : "Sequence.Protocol",
        "key.typeusr" : "$SST_pmD",
        "key.usr" : "s:ST"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Collection : <Type usr=\"s:ST\">Sequence<\/Type> where <Type usr=\"s:Sl4Selfxmfp\">Self<\/Type>.SubSequence : <Type usr=\"s:Sl\">Collection<\/Type><\/Declaration>",
        "key.bodylength" : 670,
        "key.bodyoffset" : 1547,
        "key.doc.declaration" : "protocol Collection : Sequence where Self.SubSequence : Collection",
        "key.doc.discussion" : [
          {
            "Para" : "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the `Collection` protocol declares and implements. In addition to the operations that collections inherit from the `Sequence` protocol, you gain access to methods that depend on accessing an element at a specific position in a collection."
          },
          {
            "Para" : "For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `firstSpace` constant is an index into the `text` string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, `firstSpace` is used to extract the prefix that contains elements up to that index."
          },
          {
            "Para" : "You can access an element of a collection through its subscript by using any valid index except the collection’s `endIndex` property. This property is a “past the end” index that does not correspond with any element of the collection."
          },
          {
            "Para" : "Here’s an example of accessing the first character in a string through its subscript:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Collection` protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of `text` using the `first` property, which has the value of the first element of the collection, or `nil` if the collection is empty."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s `startIndex` property and finding every successor up to, and including, the `endIndex` property. All other values of the `Index` type, such as the `startIndex` property of a different collection, are invalid indices for this collection."
          },
          {
            "Para" : "Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the `MutableCollection` and `RangeReplaceableCollection` protocols, as well as for the specific type you’re using."
          },
          {
            "Para" : "You can access a slice of a collection through its ranged subscript or by calling methods like `prefix(while:)` or `suffix(_:)`. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics."
          },
          {
            "Para" : "The following example creates a `firstWord` constant by using the `prefix(while:)` method to get a slice of the `text` string."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can retrieve the same slice using the string’s ranged subscript, which takes a range expression."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The retrieved slice of `text` is equivalent in each of these cases."
          },
          {
            "Para" : "A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created."
          },
          {
            "Para" : "For example, suppose you have an array holding the number of absences from each class during a session."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:"
          },
          {
            "List-Number" : ""
          },
          {
            "Para" : "Here’s an implementation of those steps:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice."
          },
          {
            "Para" : "For example, if you update the last element of the `absences` array from `0` to `2`, the `secondHalf` slice is unchanged."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Although a sequence can be consumed as it is traversed, a collection is guaranteed to be : Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the `contains(_:)` method to test whether a collection includes an element."
          },
          {
            "Para" : "Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the `characters` view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the `Collection` protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add `Collection` conformance to your type, you must declare at least the following requirements:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "Types that conform to `Collection` are expected to provide the `startIndex` and `endIndex` properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees."
          },
          {
            "Para" : "The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its `count` property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its `count` property is an O() operation."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Collection<\/Name><USR>s:Sl<\/USR><Declaration>protocol Collection : Sequence where Self.SubSequence : Collection<\/Declaration><CommentParts><Abstract><Para>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.<\/Para><\/Abstract><Discussion><Para>Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the <codeVoice>Collection<\/codeVoice> protocol declares and implements. In addition to the operations that collections inherit from the <codeVoice>Sequence<\/codeVoice> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.<\/Para><Para>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let text = \"Buffalo buffalo buffalo buffalo.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstSpace<\/codeVoice> constant is an index into the <codeVoice>text<\/codeVoice> string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, <codeVoice>firstSpace<\/codeVoice> is used to extract the prefix that contains elements up to that index.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Individual Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access an element of a collection through its subscript by using any valid index except the collection’s <codeVoice>endIndex<\/codeVoice> property. This property is a “past the end” index that does not correspond with any element of the collection.<\/Para><Para>Here’s an example of accessing the first character in a string through its subscript:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstChar = text[text.startIndex]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstChar)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"B\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Collection<\/codeVoice> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of <codeVoice>text<\/codeVoice> using the <codeVoice>first<\/codeVoice> property, which has the value of the first element of the collection, or <codeVoice>nil<\/codeVoice> if the collection is empty.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(text.first)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"B\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s <codeVoice>startIndex<\/codeVoice> property and finding every successor up to, and including, the <codeVoice>endIndex<\/codeVoice> property. All other values of the <codeVoice>Index<\/codeVoice> type, such as the <codeVoice>startIndex<\/codeVoice> property of a different collection, are invalid indices for this collection.<\/Para><Para>Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the <codeVoice>MutableCollection<\/codeVoice> and <codeVoice>RangeReplaceableCollection<\/codeVoice> protocols, as well as for the specific type you’re using.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Slices of a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access a slice of a collection through its ranged subscript or by calling methods like <codeVoice>prefix(while:)<\/codeVoice> or <codeVoice>suffix(_:)<\/codeVoice>. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.<\/Para><Para>The following example creates a <codeVoice>firstWord<\/codeVoice> constant by using the <codeVoice>prefix(while:)<\/codeVoice> method to get a slice of the <codeVoice>text<\/codeVoice> string.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstWord = text.prefix(while: { $0 != \" \" })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstWord)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The retrieved slice of <codeVoice>text<\/codeVoice> is equivalent in each of these cases.<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Share Indices<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.<\/Para><Para>For example, suppose you have an array holding the number of absences from each class during a session.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var absences = [0, 2, 0, 4, 0, 3, 1, 0]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:<\/Para><List-Number><Item><Para>Create a slice of the <codeVoice>absences<\/codeVoice> array that holds the second half of the days.<\/Para><\/Item><Item><Para>Use the <codeVoice>max(by:)<\/codeVoice> method to determine the index of the day with the most absences.<\/Para><\/Item><Item><Para>Print the result using the index found in step 2 on the original <codeVoice>absences<\/codeVoice> array.<\/Para><\/Item><\/List-Number><Para>Here’s an implementation of those steps:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let secondHalf = absences.suffix(absences.count \/ 2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Highest second-half absences: \\(absences[i])\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Highest second-half absences: 3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Inherit Collection Semantics<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.<\/Para><Para>For example, if you update the last element of the <codeVoice>absences<\/codeVoice> array from <codeVoice>0<\/codeVoice> to <codeVoice>2<\/codeVoice>, the <codeVoice>secondHalf<\/codeVoice> slice is unchanged.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[absences[7] = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(absences)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 2, 0, 4, 0, 3, 1, 2]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondHalf)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 3, 1, 0]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Traversing a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <emphasis>multipass<\/emphasis>: Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <codeVoice>contains(_:)<\/codeVoice> method to test whether a collection includes an element.<\/Para><Para>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the <codeVoice>characters<\/codeVoice> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let word = \"Swift\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for character in word {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(character)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in word.indices {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(word[i])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Collection Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <codeVoice>Collection<\/codeVoice> protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add <codeVoice>Collection<\/codeVoice> conformance to your type, you must declare at least the following requirements:<\/Para><List-Bullet><Item><Para>The <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties<\/Para><\/Item><Item><Para>A subscript that provides at least read-only access to your type’s elements<\/Para><\/Item><Item><Para>The <codeVoice>index(after:)<\/codeVoice> method for advancing an index into your collection<\/Para><\/Item><\/List-Bullet><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Types that conform to <codeVoice>Collection<\/codeVoice> are expected to provide the <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.<\/Para><Para>The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <codeVoice>count<\/codeVoice> property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <codeVoice>count<\/codeVoice> property is an O(<emphasis>n<\/emphasis>) operation.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Collection",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Collection<\/decl.name> : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement><ref.generic_type_param usr=\"s:Sl4Selfxmfp\">Self<\/ref.generic_type_param>.SubSequence : <ref.protocol usr=\"s:Sl\">Collection<\/ref.protocol><\/decl.generic_type_requirement><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 693,
        "key.modulename" : "Swift",
        "key.name" : "Collection",
        "key.namelength" : 10,
        "key.nameoffset" : 1535,
        "key.offset" : 1525,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func accumulating(_ initial: <Type usr=\"s:Sl7ElementQa\">Element<\/Type>, _ op: (<Type usr=\"s:Sl7ElementQa\">Element<\/Type>, <Type usr=\"s:Sl7ElementQa\">Element<\/Type>) -&gt; <Type usr=\"s:Sl7ElementQa\">Element<\/Type>) -&gt; [<Type usr=\"s:Sl7ElementQa\">Element<\/Type>]<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1856
              }
            ],
            "key.bodylength" : 238,
            "key.bodyoffset" : 1977,
            "key.doc.column" : 17,
            "key.doc.comment" : "- Returns: Array of `Element` values starting with the given `initial`, followed by each\nelement combined with the accumulation with the given `op`.\n\n    let numbers = [1,2,3]\n    let accumulatedAdditionFrom10 = numbers.accumulating(10,+) \/\/ => [10,11,13]",
            "key.doc.declaration" : "public func accumulating(_ initial: Element, _ op: (Element, Element) -> Element) -> [Element]",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift\" line=\"65\" column=\"17\"><Name>accumulating(_:_:)<\/Name><USR>s:Sl7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF<\/USR><Declaration>public func accumulating(_ initial: Element, _ op: (Element, Element) -&gt; Element) -&gt; [Element]<\/Declaration><CommentParts><ResultDiscussion><Para>Array of <codeVoice>Element<\/codeVoice> values starting with the given <codeVoice>initial<\/codeVoice>, followed by each element combined with the accumulation with the given <codeVoice>op<\/codeVoice>.<\/Para><Para>let numbers = [1,2,3] let accumulatedAdditionFrom10 = numbers.accumulating(10,+) \/\/ =&gt; [10,11,13]<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 65,
            "key.doc.name" : "accumulating(_:_:)",
            "key.doc.result_discussion" : [
              {
                "Para" : "Array of `Element` values starting with the given `initial`, followed by each element combined with the accumulation with the given `op`."
              },
              {
                "Para" : "let numbers = [1,2,3] let accumulatedAdditionFrom10 = numbers.accumulating(10,+) \/\/ => [10,11,13]"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 299,
            "key.docoffset" : 1553,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>accumulating<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>initial<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>op<\/decl.var.parameter.name>: <decl.var.parameter.type>(<decl.var.parameter><decl.var.parameter.type><ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.type><ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype><\/decl.function.returntype><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype>[<ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype>]<\/decl.function.returntype><\/decl.function.method.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 353,
            "key.name" : "accumulating(_:_:)",
            "key.namelength" : 90,
            "key.nameoffset" : 1868,
            "key.offset" : 1863,
            "key.parsed_declaration" : "public func accumulating(\n    _ initial: Element,\n    _ op: (Element,Element) -> Element\n) -> [Element]",
            "key.parsed_scope.end" : 78,
            "key.parsed_scope.start" : 65,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:ST7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF\">accumulating(_: Element, _: (Element, Element) -&gt; Element) -&gt; [Element]<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>var result: [<Type usr=\"s:Sl4Selfxmfp\">Self<\/Type>.Element]<\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>result<\/decl.name>: <decl.var.type>[<ref.generic_type_param usr=\"s:Sl4Selfxmfp\">Self<\/ref.generic_type_param>.Element]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 26,
                "key.name" : "result",
                "key.namelength" : 6,
                "key.nameoffset" : 1990,
                "key.offset" : 1986,
                "key.parsed_declaration" : "var result: [Element] = []",
                "key.parsed_scope.end" : 70,
                "key.parsed_scope.start" : 70,
                "key.typename" : "[Self.Element]",
                "key.typeusr" : "$SSay7ElementSTQzGD",
                "key.usr" : "s:Sl7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF6resultL_AEvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var accum: <Type usr=\"s:Sl4Selfxmfp\">Self<\/Type>.Element<\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>accum<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:Sl4Selfxmfp\">Self<\/ref.generic_type_param>.Element<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 28,
                "key.name" : "accum",
                "key.namelength" : 5,
                "key.nameoffset" : 2063,
                "key.offset" : 2059,
                "key.parsed_declaration" : "var accum: Element = initial",
                "key.parsed_scope.end" : 72,
                "key.parsed_scope.start" : 72,
                "key.typename" : "Self.Element",
                "key.typeusr" : "$S7ElementSTQzD",
                "key.usr" : "s:Sl7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF5accumL_ADvp"
              }
            ],
            "key.typename" : "<Self where Self : Collection> (Self) -> (Self.Element, (Self.Element, Self.Element) -> Self.Element) -> [Self.Element]",
            "key.typeusr" : "$SySay7ElementQzGAB_A2B_ABtXEtcD",
            "key.usr" : "s:Sl7AlgebraE12accumulatingySay7ElementQzGAD_A2D_ADtXEtF"
          }
        ],
        "key.typename" : "Collection.Protocol",
        "key.typeusr" : "$SSl_pmD",
        "key.usr" : "s:Sl"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Collection : <Type usr=\"s:ST\">Sequence<\/Type> where <Type usr=\"s:Sl4Selfxmfp\">Self<\/Type>.SubSequence : <Type usr=\"s:Sl\">Collection<\/Type><\/Declaration>",
        "key.bodylength" : 341,
        "key.bodyoffset" : 2266,
        "key.doc.declaration" : "protocol Collection : Sequence where Self.SubSequence : Collection",
        "key.doc.discussion" : [
          {
            "Para" : "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the `Collection` protocol declares and implements. In addition to the operations that collections inherit from the `Sequence` protocol, you gain access to methods that depend on accessing an element at a specific position in a collection."
          },
          {
            "Para" : "For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `firstSpace` constant is an index into the `text` string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, `firstSpace` is used to extract the prefix that contains elements up to that index."
          },
          {
            "Para" : "You can access an element of a collection through its subscript by using any valid index except the collection’s `endIndex` property. This property is a “past the end” index that does not correspond with any element of the collection."
          },
          {
            "Para" : "Here’s an example of accessing the first character in a string through its subscript:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Collection` protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of `text` using the `first` property, which has the value of the first element of the collection, or `nil` if the collection is empty."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s `startIndex` property and finding every successor up to, and including, the `endIndex` property. All other values of the `Index` type, such as the `startIndex` property of a different collection, are invalid indices for this collection."
          },
          {
            "Para" : "Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the `MutableCollection` and `RangeReplaceableCollection` protocols, as well as for the specific type you’re using."
          },
          {
            "Para" : "You can access a slice of a collection through its ranged subscript or by calling methods like `prefix(while:)` or `suffix(_:)`. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics."
          },
          {
            "Para" : "The following example creates a `firstWord` constant by using the `prefix(while:)` method to get a slice of the `text` string."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can retrieve the same slice using the string’s ranged subscript, which takes a range expression."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The retrieved slice of `text` is equivalent in each of these cases."
          },
          {
            "Para" : "A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created."
          },
          {
            "Para" : "For example, suppose you have an array holding the number of absences from each class during a session."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:"
          },
          {
            "List-Number" : ""
          },
          {
            "Para" : "Here’s an implementation of those steps:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice."
          },
          {
            "Para" : "For example, if you update the last element of the `absences` array from `0` to `2`, the `secondHalf` slice is unchanged."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Although a sequence can be consumed as it is traversed, a collection is guaranteed to be : Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the `contains(_:)` method to test whether a collection includes an element."
          },
          {
            "Para" : "Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the `characters` view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the `Collection` protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add `Collection` conformance to your type, you must declare at least the following requirements:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "Types that conform to `Collection` are expected to provide the `startIndex` and `endIndex` properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees."
          },
          {
            "Para" : "The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its `count` property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its `count` property is an O() operation."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Collection<\/Name><USR>s:Sl<\/USR><Declaration>protocol Collection : Sequence where Self.SubSequence : Collection<\/Declaration><CommentParts><Abstract><Para>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.<\/Para><\/Abstract><Discussion><Para>Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the <codeVoice>Collection<\/codeVoice> protocol declares and implements. In addition to the operations that collections inherit from the <codeVoice>Sequence<\/codeVoice> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.<\/Para><Para>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let text = \"Buffalo buffalo buffalo buffalo.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstSpace<\/codeVoice> constant is an index into the <codeVoice>text<\/codeVoice> string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, <codeVoice>firstSpace<\/codeVoice> is used to extract the prefix that contains elements up to that index.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Individual Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access an element of a collection through its subscript by using any valid index except the collection’s <codeVoice>endIndex<\/codeVoice> property. This property is a “past the end” index that does not correspond with any element of the collection.<\/Para><Para>Here’s an example of accessing the first character in a string through its subscript:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstChar = text[text.startIndex]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstChar)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"B\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Collection<\/codeVoice> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of <codeVoice>text<\/codeVoice> using the <codeVoice>first<\/codeVoice> property, which has the value of the first element of the collection, or <codeVoice>nil<\/codeVoice> if the collection is empty.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(text.first)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"B\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s <codeVoice>startIndex<\/codeVoice> property and finding every successor up to, and including, the <codeVoice>endIndex<\/codeVoice> property. All other values of the <codeVoice>Index<\/codeVoice> type, such as the <codeVoice>startIndex<\/codeVoice> property of a different collection, are invalid indices for this collection.<\/Para><Para>Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the <codeVoice>MutableCollection<\/codeVoice> and <codeVoice>RangeReplaceableCollection<\/codeVoice> protocols, as well as for the specific type you’re using.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Slices of a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access a slice of a collection through its ranged subscript or by calling methods like <codeVoice>prefix(while:)<\/codeVoice> or <codeVoice>suffix(_:)<\/codeVoice>. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.<\/Para><Para>The following example creates a <codeVoice>firstWord<\/codeVoice> constant by using the <codeVoice>prefix(while:)<\/codeVoice> method to get a slice of the <codeVoice>text<\/codeVoice> string.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstWord = text.prefix(while: { $0 != \" \" })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstWord)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The retrieved slice of <codeVoice>text<\/codeVoice> is equivalent in each of these cases.<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Share Indices<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.<\/Para><Para>For example, suppose you have an array holding the number of absences from each class during a session.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var absences = [0, 2, 0, 4, 0, 3, 1, 0]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:<\/Para><List-Number><Item><Para>Create a slice of the <codeVoice>absences<\/codeVoice> array that holds the second half of the days.<\/Para><\/Item><Item><Para>Use the <codeVoice>max(by:)<\/codeVoice> method to determine the index of the day with the most absences.<\/Para><\/Item><Item><Para>Print the result using the index found in step 2 on the original <codeVoice>absences<\/codeVoice> array.<\/Para><\/Item><\/List-Number><Para>Here’s an implementation of those steps:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let secondHalf = absences.suffix(absences.count \/ 2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Highest second-half absences: \\(absences[i])\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Highest second-half absences: 3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Inherit Collection Semantics<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.<\/Para><Para>For example, if you update the last element of the <codeVoice>absences<\/codeVoice> array from <codeVoice>0<\/codeVoice> to <codeVoice>2<\/codeVoice>, the <codeVoice>secondHalf<\/codeVoice> slice is unchanged.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[absences[7] = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(absences)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 2, 0, 4, 0, 3, 1, 2]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondHalf)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 3, 1, 0]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Traversing a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <emphasis>multipass<\/emphasis>: Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <codeVoice>contains(_:)<\/codeVoice> method to test whether a collection includes an element.<\/Para><Para>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the <codeVoice>characters<\/codeVoice> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let word = \"Swift\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for character in word {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(character)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in word.indices {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(word[i])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Collection Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <codeVoice>Collection<\/codeVoice> protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add <codeVoice>Collection<\/codeVoice> conformance to your type, you must declare at least the following requirements:<\/Para><List-Bullet><Item><Para>The <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties<\/Para><\/Item><Item><Para>A subscript that provides at least read-only access to your type’s elements<\/Para><\/Item><Item><Para>The <codeVoice>index(after:)<\/codeVoice> method for advancing an index into your collection<\/Para><\/Item><\/List-Bullet><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Types that conform to <codeVoice>Collection<\/codeVoice> are expected to provide the <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.<\/Para><Para>The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <codeVoice>count<\/codeVoice> property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <codeVoice>count<\/codeVoice> property is an O(<emphasis>n<\/emphasis>) operation.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Collection",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Collection<\/decl.name> : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement><ref.generic_type_param usr=\"s:Sl4Selfxmfp\">Self<\/ref.generic_type_param>.SubSequence : <ref.protocol usr=\"s:Sl\">Collection<\/ref.protocol><\/decl.generic_type_requirement><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 388,
        "key.modulename" : "Swift",
        "key.name" : "Collection",
        "key.namelength" : 10,
        "key.nameoffset" : 2230,
        "key.offset" : 2220,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var accumulatingSum: [<Type usr=\"s:Sl7ElementQa\">Element<\/Type>] { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2524
              }
            ],
            "key.bodylength" : 42,
            "key.bodyoffset" : 2563,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: Array of `Element` from `.zero`, applying `+` to each element contained herein\nand the accumulative value.\n\n    let numbers = [2,1,2]\n    let accumulated = numbers.accumulatingSum \/\/ => [0,2,3]",
            "key.doc.declaration" : "public var accumulatingSum: [Element] { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift\" line=\"89\" column=\"16\"><Name>accumulatingSum<\/Name><USR>s:Sl7AlgebraAA8Additive7ElementRpzrlE15accumulatingSumSayADGvp<\/USR><Declaration>public var accumulatingSum: [Element] { get }<\/Declaration><CommentParts><ResultDiscussion><Para>Array of <codeVoice>Element<\/codeVoice> from <codeVoice>.zero<\/codeVoice>, applying <codeVoice>+<\/codeVoice> to each element contained herein and the accumulative value.<\/Para><Para>let numbers = [2,1,2] let accumulated = numbers.accumulatingSum \/\/ =&gt; [0,2,3]<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 89,
            "key.doc.name" : "accumulatingSum",
            "key.doc.result_discussion" : [
              {
                "Para" : "Array of `Element` from `.zero`, applying `+` to each element contained herein and the accumulative value."
              },
              {
                "Para" : "let numbers = [2,1,2] let accumulated = numbers.accumulatingSum \/\/ => [0,2,3]"
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 248,
            "key.docoffset" : 2272,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>accumulatingSum<\/decl.name>: <decl.var.type>[<ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype>]<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 75,
            "key.name" : "accumulatingSum",
            "key.namelength" : 15,
            "key.nameoffset" : 2535,
            "key.offset" : 2531,
            "key.parsed_declaration" : "public var accumulatingSum: [Element]",
            "key.parsed_scope.end" : 91,
            "key.parsed_scope.start" : 89,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:ST7AlgebraAA8Additive7ElementRpzrlE15accumulatingSumSayADGvp\">accumulatingSum<\/RelatedName>"
              }
            ],
            "key.typename" : "[Self.Element]",
            "key.typeusr" : "$SSay7ElementSTQzGD",
            "key.usr" : "s:Sl7AlgebraAA8Additive7ElementRpzrlE15accumulatingSumSayADGvp"
          }
        ],
        "key.typename" : "Collection.Protocol",
        "key.typeusr" : "$SSl_pmD",
        "key.usr" : "s:Sl"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Collection : <Type usr=\"s:ST\">Sequence<\/Type> where <Type usr=\"s:Sl4Selfxmfp\">Self<\/Type>.SubSequence : <Type usr=\"s:Sl\">Collection<\/Type><\/Declaration>",
        "key.bodylength" : 347,
        "key.bodyoffset" : 2662,
        "key.doc.declaration" : "protocol Collection : Sequence where Self.SubSequence : Collection",
        "key.doc.discussion" : [
          {
            "Para" : "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the `Collection` protocol declares and implements. In addition to the operations that collections inherit from the `Sequence` protocol, you gain access to methods that depend on accessing an element at a specific position in a collection."
          },
          {
            "Para" : "For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `firstSpace` constant is an index into the `text` string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, `firstSpace` is used to extract the prefix that contains elements up to that index."
          },
          {
            "Para" : "You can access an element of a collection through its subscript by using any valid index except the collection’s `endIndex` property. This property is a “past the end” index that does not correspond with any element of the collection."
          },
          {
            "Para" : "Here’s an example of accessing the first character in a string through its subscript:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Collection` protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of `text` using the `first` property, which has the value of the first element of the collection, or `nil` if the collection is empty."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s `startIndex` property and finding every successor up to, and including, the `endIndex` property. All other values of the `Index` type, such as the `startIndex` property of a different collection, are invalid indices for this collection."
          },
          {
            "Para" : "Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the `MutableCollection` and `RangeReplaceableCollection` protocols, as well as for the specific type you’re using."
          },
          {
            "Para" : "You can access a slice of a collection through its ranged subscript or by calling methods like `prefix(while:)` or `suffix(_:)`. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics."
          },
          {
            "Para" : "The following example creates a `firstWord` constant by using the `prefix(while:)` method to get a slice of the `text` string."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can retrieve the same slice using the string’s ranged subscript, which takes a range expression."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The retrieved slice of `text` is equivalent in each of these cases."
          },
          {
            "Para" : "A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created."
          },
          {
            "Para" : "For example, suppose you have an array holding the number of absences from each class during a session."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:"
          },
          {
            "List-Number" : ""
          },
          {
            "Para" : "Here’s an implementation of those steps:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice."
          },
          {
            "Para" : "For example, if you update the last element of the `absences` array from `0` to `2`, the `secondHalf` slice is unchanged."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Although a sequence can be consumed as it is traversed, a collection is guaranteed to be : Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the `contains(_:)` method to test whether a collection includes an element."
          },
          {
            "Para" : "Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the `characters` view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the `Collection` protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add `Collection` conformance to your type, you must declare at least the following requirements:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "Types that conform to `Collection` are expected to provide the `startIndex` and `endIndex` properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees."
          },
          {
            "Para" : "The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its `count` property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its `count` property is an O() operation."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Collection<\/Name><USR>s:Sl<\/USR><Declaration>protocol Collection : Sequence where Self.SubSequence : Collection<\/Declaration><CommentParts><Abstract><Para>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.<\/Para><\/Abstract><Discussion><Para>Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the <codeVoice>Collection<\/codeVoice> protocol declares and implements. In addition to the operations that collections inherit from the <codeVoice>Sequence<\/codeVoice> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.<\/Para><Para>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let text = \"Buffalo buffalo buffalo buffalo.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstSpace<\/codeVoice> constant is an index into the <codeVoice>text<\/codeVoice> string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, <codeVoice>firstSpace<\/codeVoice> is used to extract the prefix that contains elements up to that index.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Individual Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access an element of a collection through its subscript by using any valid index except the collection’s <codeVoice>endIndex<\/codeVoice> property. This property is a “past the end” index that does not correspond with any element of the collection.<\/Para><Para>Here’s an example of accessing the first character in a string through its subscript:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstChar = text[text.startIndex]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstChar)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"B\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Collection<\/codeVoice> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of <codeVoice>text<\/codeVoice> using the <codeVoice>first<\/codeVoice> property, which has the value of the first element of the collection, or <codeVoice>nil<\/codeVoice> if the collection is empty.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(text.first)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"B\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s <codeVoice>startIndex<\/codeVoice> property and finding every successor up to, and including, the <codeVoice>endIndex<\/codeVoice> property. All other values of the <codeVoice>Index<\/codeVoice> type, such as the <codeVoice>startIndex<\/codeVoice> property of a different collection, are invalid indices for this collection.<\/Para><Para>Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the <codeVoice>MutableCollection<\/codeVoice> and <codeVoice>RangeReplaceableCollection<\/codeVoice> protocols, as well as for the specific type you’re using.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Slices of a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access a slice of a collection through its ranged subscript or by calling methods like <codeVoice>prefix(while:)<\/codeVoice> or <codeVoice>suffix(_:)<\/codeVoice>. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.<\/Para><Para>The following example creates a <codeVoice>firstWord<\/codeVoice> constant by using the <codeVoice>prefix(while:)<\/codeVoice> method to get a slice of the <codeVoice>text<\/codeVoice> string.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstWord = text.prefix(while: { $0 != \" \" })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstWord)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The retrieved slice of <codeVoice>text<\/codeVoice> is equivalent in each of these cases.<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Share Indices<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.<\/Para><Para>For example, suppose you have an array holding the number of absences from each class during a session.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var absences = [0, 2, 0, 4, 0, 3, 1, 0]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:<\/Para><List-Number><Item><Para>Create a slice of the <codeVoice>absences<\/codeVoice> array that holds the second half of the days.<\/Para><\/Item><Item><Para>Use the <codeVoice>max(by:)<\/codeVoice> method to determine the index of the day with the most absences.<\/Para><\/Item><Item><Para>Print the result using the index found in step 2 on the original <codeVoice>absences<\/codeVoice> array.<\/Para><\/Item><\/List-Number><Para>Here’s an implementation of those steps:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let secondHalf = absences.suffix(absences.count \/ 2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Highest second-half absences: \\(absences[i])\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Highest second-half absences: 3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Inherit Collection Semantics<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.<\/Para><Para>For example, if you update the last element of the <codeVoice>absences<\/codeVoice> array from <codeVoice>0<\/codeVoice> to <codeVoice>2<\/codeVoice>, the <codeVoice>secondHalf<\/codeVoice> slice is unchanged.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[absences[7] = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(absences)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 2, 0, 4, 0, 3, 1, 2]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondHalf)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 3, 1, 0]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Traversing a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <emphasis>multipass<\/emphasis>: Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <codeVoice>contains(_:)<\/codeVoice> method to test whether a collection includes an element.<\/Para><Para>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the <codeVoice>characters<\/codeVoice> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let word = \"Swift\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for character in word {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(character)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in word.indices {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(word[i])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Collection Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <codeVoice>Collection<\/codeVoice> protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add <codeVoice>Collection<\/codeVoice> conformance to your type, you must declare at least the following requirements:<\/Para><List-Bullet><Item><Para>The <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties<\/Para><\/Item><Item><Para>A subscript that provides at least read-only access to your type’s elements<\/Para><\/Item><Item><Para>The <codeVoice>index(after:)<\/codeVoice> method for advancing an index into your collection<\/Para><\/Item><\/List-Bullet><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Types that conform to <codeVoice>Collection<\/codeVoice> are expected to provide the <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.<\/Para><Para>The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <codeVoice>count<\/codeVoice> property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <codeVoice>count<\/codeVoice> property is an O(<emphasis>n<\/emphasis>) operation.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Collection",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Collection<\/decl.name> : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement><ref.generic_type_param usr=\"s:Sl4Selfxmfp\">Self<\/ref.generic_type_param>.SubSequence : <ref.protocol usr=\"s:Sl\">Collection<\/ref.protocol><\/decl.generic_type_requirement><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 400,
        "key.modulename" : "Swift",
        "key.name" : "Collection",
        "key.namelength" : 10,
        "key.nameoffset" : 2620,
        "key.offset" : 2610,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var accumulatingProduct: [<Type usr=\"s:Sl7ElementQa\">Element<\/Type>] { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2923
              }
            ],
            "key.bodylength" : 41,
            "key.bodyoffset" : 2966,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: Array of `Element` from `.one`, applying `*` to each element contained herein\nand the accumulative value.\n\n    let numbers = [2,1,2]\n    let accumulated = numbers.accumulatingProduct \/\/ => [1,2,2]",
            "key.doc.declaration" : "public var accumulatingProduct: [Element] { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift\" line=\"102\" column=\"16\"><Name>accumulatingProduct<\/Name><USR>s:Sl7AlgebraAA14Multiplicative7ElementRpzrlE19accumulatingProductSayADGvp<\/USR><Declaration>public var accumulatingProduct: [Element] { get }<\/Declaration><CommentParts><ResultDiscussion><Para>Array of <codeVoice>Element<\/codeVoice> from <codeVoice>.one<\/codeVoice>, applying <codeVoice>*<\/codeVoice> to each element contained herein and the accumulative value.<\/Para><Para>let numbers = [2,1,2] let accumulated = numbers.accumulatingProduct \/\/ =&gt; [1,2,2]<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 102,
            "key.doc.name" : "accumulatingProduct",
            "key.doc.result_discussion" : [
              {
                "Para" : "Array of `Element` from `.one`, applying `*` to each element contained herein and the accumulative value."
              },
              {
                "Para" : "let numbers = [2,1,2] let accumulated = numbers.accumulatingProduct \/\/ => [1,2,2]"
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 251,
            "key.docoffset" : 2668,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Accumulate.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>accumulatingProduct<\/decl.name>: <decl.var.type>[<ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype>]<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 78,
            "key.name" : "accumulatingProduct",
            "key.namelength" : 19,
            "key.nameoffset" : 2934,
            "key.offset" : 2930,
            "key.parsed_declaration" : "public var accumulatingProduct: [Element]",
            "key.parsed_scope.end" : 104,
            "key.parsed_scope.start" : 102,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:ST7AlgebraAA14Multiplicative7ElementRpzrlE19accumulatingProductSayADGvp\">accumulatingProduct<\/RelatedName>"
              }
            ],
            "key.typename" : "[Self.Element]",
            "key.typeusr" : "$SSay7ElementSTQzGD",
            "key.usr" : "s:Sl7AlgebraAA14Multiplicative7ElementRpzrlE19accumulatingProductSayADGvp"
          }
        ],
        "key.typename" : "Collection.Protocol",
        "key.typeusr" : "$SSl_pmD",
        "key.usr" : "s:Sl"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Additive.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 199,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol Additive : <Type usr=\"s:7Algebra17AdditiveSemigroupP\">AdditiveSemigroup<\/Type>, <Type usr=\"s:7Algebra4ZeroP\">Zero<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 145
          }
        ],
        "key.bodylength" : 1,
        "key.bodyoffset" : 196,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface for types which can be viewed as an `Sum` monoid.",
        "key.doc.declaration" : "public protocol Additive : AdditiveSemigroup, Zero",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Additive.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Additive.swift\" line=\"10\" column=\"17\"><Name>Additive<\/Name><USR>s:7Algebra8AdditiveP<\/USR><Declaration>public protocol Additive : AdditiveSemigroup, Zero<\/Declaration><CommentParts><Abstract><Para>Interface for types which can be viewed as an <codeVoice>Sum<\/codeVoice> monoid.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "Additive",
        "key.doc.type" : "Class",
        "key.doclength" : 64,
        "key.docoffset" : 81,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 4,
            "key.offset" : 171
          },
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 17,
            "key.offset" : 177
          }
        ],
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Additive.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Additive<\/decl.name> : <ref.protocol usr=\"s:7Algebra17AdditiveSemigroupP\">AdditiveSemigroup<\/ref.protocol>, <ref.protocol usr=\"s:7Algebra4ZeroP\">Zero<\/ref.protocol><\/decl.protocol>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Zero"
          },
          {
            "key.name" : "AdditiveSemigroup"
          }
        ],
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 46,
        "key.name" : "Additive",
        "key.namelength" : 8,
        "key.nameoffset" : 161,
        "key.offset" : 152,
        "key.parsed_declaration" : "public protocol Additive: Zero, AdditiveSemigroup",
        "key.parsed_scope.end" : 10,
        "key.parsed_scope.start" : 10,
        "key.runtime_name" : "_TtP8Additive8Additive_",
        "key.typename" : "Additive.Protocol",
        "key.typeusr" : "$S7Algebra8Additive_pmD",
        "key.usr" : "s:7Algebra8AdditiveP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 271,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol AdditiveSemigroup<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 155
          }
        ],
        "key.bodylength" : 79,
        "key.bodyoffset" : 190,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface for semigroups with an additive binary operation.",
        "key.doc.declaration" : "public protocol AdditiveSemigroup",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift\" line=\"10\" column=\"17\"><Name>AdditiveSemigroup<\/Name><USR>s:7Algebra17AdditiveSemigroupP<\/USR><Declaration>public protocol AdditiveSemigroup<\/Declaration><CommentParts><Abstract><Para>Interface for semigroups with an additive binary operation.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "AdditiveSemigroup",
        "key.doc.type" : "Class",
        "key.doclength" : 64,
        "key.docoffset" : 91,
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>AdditiveSemigroup<\/decl.name><\/decl.protocol>",
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 108,
        "key.name" : "AdditiveSemigroup",
        "key.namelength" : 17,
        "key.nameoffset" : 171,
        "key.offset" : 162,
        "key.parsed_declaration" : "public protocol AdditiveSemigroup",
        "key.parsed_scope.end" : 14,
        "key.parsed_scope.start" : 10,
        "key.runtime_name" : "_TtP17AdditiveSemigroup17AdditiveSemigroup_",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>static func + (lhs: <Type usr=\"s:7Algebra17AdditiveSemigroupP4Selfxmfp\">Self<\/Type>, rhs: <Type usr=\"s:7Algebra17AdditiveSemigroupP4Selfxmfp\">Self<\/Type>) -&gt; <Type usr=\"s:7Algebra17AdditiveSemigroupP4Selfxmfp\">Self<\/Type><\/Declaration>",
            "key.doc.column" : 17,
            "key.doc.comment" : "Additive operation.",
            "key.doc.declaration" : "static func + (lhs: Self, rhs: Self) -> Self",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift\" line=\"13\" column=\"17\"><Name>+(_:_:)<\/Name><USR>s:7Algebra17AdditiveSemigroupP1poiyxx_xtFZ<\/USR><Declaration>static func + (lhs: Self, rhs: Self) -&gt; Self<\/Declaration><CommentParts><Abstract><Para>Additive operation.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 13,
            "key.doc.name" : "+(_:_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 24,
            "key.docoffset" : 196,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>+ <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra17AdditiveSemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra17AdditiveSemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.generic_type_param usr=\"s:7Algebra17AdditiveSemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 44,
            "key.name" : "+(_:_:)",
            "key.namelength" : 24,
            "key.nameoffset" : 236,
            "key.offset" : 224,
            "key.parsed_declaration" : "static func + (lhs: Self, rhs: Self) -> Self",
            "key.parsed_scope.end" : 13,
            "key.parsed_scope.start" : 13,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh7AlgebraE1poiyShyxGAC_ACtFZ\">+ (_: Set, _: Set) -&gt; Set<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SF1poiyxx_xtFZ\">+ (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sf1poiyS2f_SftFZ\">+ (_: Float, _: Float) -&gt; Float<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sd1poiyS2d_SdtFZ\">+ (_: Double, _: Double) -&gt; Double<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7Float80V1poiyA2B_ABtFZ\">+ (_: Float80, _: Float80) -&gt; Float80<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sj1poiyxx_xtFZ\">+ (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SjsE1popyxxFZ\">+(_:)<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sz1poiyxx_xtFZ\">+ (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V1poiyA2B_ABtFZ\">+ (_: UInt8, _: UInt8) -&gt; UInt8<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V1poiyA2B_ABtFZ\">+ (_: Int8, _: Int8) -&gt; Int8<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V1poiyA2B_ABtFZ\">+ (_: UInt16, _: UInt16) -&gt; UInt16<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V1poiyA2B_ABtFZ\">+ (_: Int16, _: Int16) -&gt; Int16<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V1poiyA2B_ABtFZ\">+ (_: UInt32, _: UInt32) -&gt; UInt32<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V1poiyA2B_ABtFZ\">+ (_: Int32, _: Int32) -&gt; Int32<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V1poiyA2B_ABtFZ\">+ (_: UInt64, _: UInt64) -&gt; UInt64<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V1poiyA2B_ABtFZ\">+ (_: Int64, _: Int64) -&gt; Int64<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su1poiyS2u_SutFZ\">+ (_: UInt, _: UInt) -&gt; UInt<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si1poiyS2i_SitFZ\">+ (_: Int, _: Int) -&gt; Int<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SmsE1poiyxx_qd__tSTRd__7ElementQyd__ABRtzlFZ\">+ &lt;Other&gt;(_: Self, _: Other) -&gt; Self where Other : Sequence, Self.Element == Other.Element<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SmsE1poiyxqd___xtSTRd__7ElementQyd__ABRtzlFZ\">+ &lt;Other&gt;(_: Other, _: Self) -&gt; Self where Other : Sequence, Self.Element == Other.Element<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SmsE1poiyxx_qd__tSmRd__7ElementQyd__ABRtzlFZ\">+ &lt;Other&gt;(_: Self, _: Other) -&gt; Self where Other : RangeReplaceableCollection, Self.Element == Other.Element<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sxss8_PointerRzrlE1poiyxx_6StrideSxQztFZ\">+ (_: Self, _: Self.Stride) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sxss8_PointerRzrlE1poiyx6StrideSxQz_xtFZ\">+ (_: Self.Stride, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS1poiyS2S_SStFZ\">+ (_: String, _: String) -&gt; String<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:7Algebra17AdditiveSemigroupP4Selfxmfp\">Self<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra17AdditiveSemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 239,
                "key.parent_loc" : 236,
                "key.parsed_declaration" : "static func + (lhs: Self, rhs: Self) -> Self",
                "key.parsed_scope.end" : 13,
                "key.parsed_scope.start" : 13,
                "key.typename" : "Self",
                "key.typeusr" : "$SxD",
                "key.usr" : "s:7Algebra17AdditiveSemigroupP1poiyxx_xtFZ3lhsL_xvp"
              }
            ],
            "key.typename" : "<Self where Self : AdditiveSemigroup> (Self.Type) -> (Self, Self) -> Self",
            "key.typeusr" : "$Syxx_xtcD",
            "key.usr" : "s:7Algebra17AdditiveSemigroupP1poiyxx_xtFZ"
          }
        ],
        "key.typename" : "AdditiveSemigroup.Protocol",
        "key.typeusr" : "$S7Algebra17AdditiveSemigroup_pmD",
        "key.usr" : "s:7Algebra17AdditiveSemigroupP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 2572,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
        "key.length" : 17,
        "key.name" : "MARK: Collections",
        "key.namelength" : 0,
        "key.nameoffset" : 0,
        "key.offset" : 84
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Sequence<\/Declaration>",
        "key.bodylength" : 238,
        "key.bodyoffset" : 165,
        "key.doc.declaration" : "protocol Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a `for`-`in` loop:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s `contains(_:)` method, which every sequence inherits from `Sequence`, instead of iterating manually:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple `for`-`in` loops on a sequence will either resume iteration or restart from the beginning:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second `for`-`in` loop."
          },
          {
            "Para" : "To establish that a type you’ve created supports nondestructive iteration, add conformance to the `Collection` protocol."
          },
          {
            "Para" : "Making your own custom types conform to `Sequence` enables many useful operations, like `for`-`in` looping and the `contains` method, without much effort. To add `Sequence` conformance to your own custom type, add a `makeIterator()` method that returns an iterator."
          },
          {
            "Para" : "Alternatively, if your type can act as its own iterator, implementing the requirements of the `IteratorProtocol` protocol and declaring conformance to both `Sequence` and `IteratorProtocol` are sufficient."
          },
          {
            "Para" : "Here’s a definition of a `Countdown` sequence that serves as its own iterator. The `makeIterator()` method is provided as a default implementation."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A sequence should provide its iterator in O(1). The `Sequence` protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O() unless documented otherwise."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Sequence<\/Name><USR>s:ST<\/USR><Declaration>protocol Sequence<\/Declaration><CommentParts><Abstract><Para>A type that provides sequential, iterated access to its elements.<\/Para><\/Abstract><Discussion><Para>A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let oneTwoThree = 1...3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for number in oneTwoThree {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var hasMosquito = false]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for bug in bugs {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if bug == \"Mosquito\" {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        hasMosquito = true]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        break]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(\"'bugs' has a mosquito: \\(hasMosquito)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"'bugs' has a mosquito: false\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Sequence<\/codeVoice> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s <codeVoice>contains(_:)<\/codeVoice> method, which every sequence inherits from <codeVoice>Sequence<\/codeVoice>, instead of iterating manually:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if bugs.contains(\"Mosquito\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Break out the bug spray.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Whew, no mosquitos!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Whew, no mosquitos!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Repeated Access<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>The <codeVoice>Sequence<\/codeVoice> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loops on a sequence will either resume iteration or restart from the beginning:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if ... some condition { break }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ No defined behavior]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><Para>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <codeVoice>Collection<\/codeVoice> protocol.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Sequence Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Making your own custom types conform to <codeVoice>Sequence<\/codeVoice> enables many useful operations, like <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> looping and the <codeVoice>contains<\/codeVoice> method, without much effort. To add <codeVoice>Sequence<\/codeVoice> conformance to your own custom type, add a <codeVoice>makeIterator()<\/codeVoice> method that returns an iterator.<\/Para><Para>Alternatively, if your type can act as its own iterator, implementing the requirements of the <codeVoice>IteratorProtocol<\/codeVoice> protocol and declaring conformance to both <codeVoice>Sequence<\/codeVoice> and <codeVoice>IteratorProtocol<\/codeVoice> are sufficient.<\/Para><Para>Here’s a definition of a <codeVoice>Countdown<\/codeVoice> sequence that serves as its own iterator. The <codeVoice>makeIterator()<\/codeVoice> method is provided as a default implementation.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[struct Countdown: Sequence, IteratorProtocol {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    var count: Int]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    mutating func next() -> Int? {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        if count == 0 {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return nil]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        } else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            defer { count -= 1 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return count]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let threeToGo = Countdown(count: 3)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in threeToGo {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(i)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A sequence should provide its iterator in O(1). The <codeVoice>Sequence<\/codeVoice> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<emphasis>n<\/emphasis>) unless documented otherwise.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Sequence",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Sequence<\/decl.name><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 281,
        "key.modulename" : "Swift",
        "key.name" : "Sequence",
        "key.namelength" : 8,
        "key.nameoffset" : 133,
        "key.offset" : 123,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var reduced: <Type usr=\"s:ST7ElementQa\">Element<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 330
              }
            ],
            "key.bodylength" : 42,
            "key.bodyoffset" : 359,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: The values contained herein, reduced from the `.identity` value of the `Monoid`,\ncomposing with the `<>` operation of the `Monoid`.",
            "key.doc.declaration" : "public var reduced: Element { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift\" line=\"16\" column=\"16\"><Name>reduced<\/Name><USR>s:ST7AlgebraAA6Monoid7ElementRpzrlE7reducedADvp<\/USR><Declaration>public var reduced: Element { get }<\/Declaration><CommentParts><ResultDiscussion><Para>The values contained herein, reduced from the <codeVoice>.identity<\/codeVoice> value of the <codeVoice>Monoid<\/codeVoice>, composing with the <codeVoice>&lt;&gt;<\/codeVoice> operation of the <codeVoice>Monoid<\/codeVoice>.<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 16,
            "key.doc.name" : "reduced",
            "key.doc.result_discussion" : [
              {
                "Para" : "The values contained herein, reduced from the `.identity` value of the `Monoid`, composing with the `<>` operation of the `Monoid`."
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 155,
            "key.docoffset" : 171,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>reduced<\/decl.name>: <decl.var.type><ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 65,
            "key.name" : "reduced",
            "key.namelength" : 7,
            "key.nameoffset" : 341,
            "key.offset" : 337,
            "key.parsed_declaration" : "public var reduced: Element",
            "key.parsed_scope.end" : 18,
            "key.parsed_scope.start" : 16,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:ST7AlgebraAA10MonoidView7ElementRpzrlE7reducedAC_5ValueQZvp\">reduced<\/RelatedName>"
              }
            ],
            "key.typename" : "Self.Element",
            "key.typeusr" : "$S7ElementSTQzD",
            "key.usr" : "s:ST7AlgebraAA6Monoid7ElementRpzrlE7reducedADvp"
          }
        ],
        "key.typename" : "Sequence.Protocol",
        "key.typeusr" : "$SST_pmD",
        "key.usr" : "s:ST"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Sequence<\/Declaration>",
        "key.bodylength" : 250,
        "key.bodyoffset" : 452,
        "key.doc.declaration" : "protocol Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a `for`-`in` loop:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s `contains(_:)` method, which every sequence inherits from `Sequence`, instead of iterating manually:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple `for`-`in` loops on a sequence will either resume iteration or restart from the beginning:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second `for`-`in` loop."
          },
          {
            "Para" : "To establish that a type you’ve created supports nondestructive iteration, add conformance to the `Collection` protocol."
          },
          {
            "Para" : "Making your own custom types conform to `Sequence` enables many useful operations, like `for`-`in` looping and the `contains` method, without much effort. To add `Sequence` conformance to your own custom type, add a `makeIterator()` method that returns an iterator."
          },
          {
            "Para" : "Alternatively, if your type can act as its own iterator, implementing the requirements of the `IteratorProtocol` protocol and declaring conformance to both `Sequence` and `IteratorProtocol` are sufficient."
          },
          {
            "Para" : "Here’s a definition of a `Countdown` sequence that serves as its own iterator. The `makeIterator()` method is provided as a default implementation."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A sequence should provide its iterator in O(1). The `Sequence` protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O() unless documented otherwise."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Sequence<\/Name><USR>s:ST<\/USR><Declaration>protocol Sequence<\/Declaration><CommentParts><Abstract><Para>A type that provides sequential, iterated access to its elements.<\/Para><\/Abstract><Discussion><Para>A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let oneTwoThree = 1...3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for number in oneTwoThree {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var hasMosquito = false]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for bug in bugs {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if bug == \"Mosquito\" {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        hasMosquito = true]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        break]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(\"'bugs' has a mosquito: \\(hasMosquito)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"'bugs' has a mosquito: false\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Sequence<\/codeVoice> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s <codeVoice>contains(_:)<\/codeVoice> method, which every sequence inherits from <codeVoice>Sequence<\/codeVoice>, instead of iterating manually:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if bugs.contains(\"Mosquito\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Break out the bug spray.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Whew, no mosquitos!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Whew, no mosquitos!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Repeated Access<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>The <codeVoice>Sequence<\/codeVoice> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loops on a sequence will either resume iteration or restart from the beginning:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if ... some condition { break }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ No defined behavior]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><Para>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <codeVoice>Collection<\/codeVoice> protocol.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Sequence Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Making your own custom types conform to <codeVoice>Sequence<\/codeVoice> enables many useful operations, like <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> looping and the <codeVoice>contains<\/codeVoice> method, without much effort. To add <codeVoice>Sequence<\/codeVoice> conformance to your own custom type, add a <codeVoice>makeIterator()<\/codeVoice> method that returns an iterator.<\/Para><Para>Alternatively, if your type can act as its own iterator, implementing the requirements of the <codeVoice>IteratorProtocol<\/codeVoice> protocol and declaring conformance to both <codeVoice>Sequence<\/codeVoice> and <codeVoice>IteratorProtocol<\/codeVoice> are sufficient.<\/Para><Para>Here’s a definition of a <codeVoice>Countdown<\/codeVoice> sequence that serves as its own iterator. The <codeVoice>makeIterator()<\/codeVoice> method is provided as a default implementation.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[struct Countdown: Sequence, IteratorProtocol {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    var count: Int]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    mutating func next() -> Int? {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        if count == 0 {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return nil]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        } else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            defer { count -= 1 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return count]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let threeToGo = Countdown(count: 3)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in threeToGo {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(i)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A sequence should provide its iterator in O(1). The <codeVoice>Sequence<\/codeVoice> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<emphasis>n<\/emphasis>) unless documented otherwise.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Sequence",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Sequence<\/decl.name><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 297,
        "key.modulename" : "Swift",
        "key.name" : "Sequence",
        "key.namelength" : 8,
        "key.nameoffset" : 416,
        "key.offset" : 406,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var reduced: <Type usr=\"s:ST7ElementQa\">Element<\/Type>.<Type usr=\"s:7Algebra10MonoidViewP5ValueQa\">Value<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 617
              }
            ],
            "key.bodylength" : 48,
            "key.bodyoffset" : 652,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: The values contained herein, reduced from the `.identity` value of the `Monoid`,\ncomposing with the `<>` operation of the `Monoid`.",
            "key.doc.declaration" : "public var reduced: Element.Value { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift\" line=\"25\" column=\"16\"><Name>reduced<\/Name><USR>s:ST7AlgebraAA10MonoidView7ElementRpzrlE7reducedAC_5ValueQZvp<\/USR><Declaration>public var reduced: Element.Value { get }<\/Declaration><CommentParts><ResultDiscussion><Para>The values contained herein, reduced from the <codeVoice>.identity<\/codeVoice> value of the <codeVoice>Monoid<\/codeVoice>, composing with the <codeVoice>&lt;&gt;<\/codeVoice> operation of the <codeVoice>Monoid<\/codeVoice>.<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 25,
            "key.doc.name" : "reduced",
            "key.doc.result_discussion" : [
              {
                "Para" : "The values contained herein, reduced from the `.identity` value of the `Monoid`, composing with the `<>` operation of the `Monoid`."
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 155,
            "key.docoffset" : 458,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>reduced<\/decl.name>: <decl.var.type><ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype>.<ref.associatedtype usr=\"s:7Algebra10MonoidViewP5ValueQa\">Value<\/ref.associatedtype><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 77,
            "key.name" : "reduced",
            "key.namelength" : 7,
            "key.nameoffset" : 628,
            "key.offset" : 624,
            "key.parsed_declaration" : "public var reduced: Element.Value",
            "key.parsed_scope.end" : 27,
            "key.parsed_scope.start" : 25,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:ST7AlgebraAA6Monoid7ElementRpzrlE7reducedADvp\">reduced<\/RelatedName>"
              }
            ],
            "key.typename" : "Self.Element.Value",
            "key.typeusr" : "$S7ElementST_5Value7Algebra10MonoidViewPQZD",
            "key.usr" : "s:ST7AlgebraAA10MonoidView7ElementRpzrlE7reducedAC_5ValueQZvp"
          }
        ],
        "key.typename" : "Sequence.Protocol",
        "key.typeusr" : "$SST_pmD",
        "key.usr" : "s:ST"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Sequence<\/Declaration>",
        "key.bodylength" : 143,
        "key.bodyoffset" : 755,
        "key.doc.declaration" : "protocol Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a `for`-`in` loop:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s `contains(_:)` method, which every sequence inherits from `Sequence`, instead of iterating manually:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple `for`-`in` loops on a sequence will either resume iteration or restart from the beginning:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second `for`-`in` loop."
          },
          {
            "Para" : "To establish that a type you’ve created supports nondestructive iteration, add conformance to the `Collection` protocol."
          },
          {
            "Para" : "Making your own custom types conform to `Sequence` enables many useful operations, like `for`-`in` looping and the `contains` method, without much effort. To add `Sequence` conformance to your own custom type, add a `makeIterator()` method that returns an iterator."
          },
          {
            "Para" : "Alternatively, if your type can act as its own iterator, implementing the requirements of the `IteratorProtocol` protocol and declaring conformance to both `Sequence` and `IteratorProtocol` are sufficient."
          },
          {
            "Para" : "Here’s a definition of a `Countdown` sequence that serves as its own iterator. The `makeIterator()` method is provided as a default implementation."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A sequence should provide its iterator in O(1). The `Sequence` protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O() unless documented otherwise."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Sequence<\/Name><USR>s:ST<\/USR><Declaration>protocol Sequence<\/Declaration><CommentParts><Abstract><Para>A type that provides sequential, iterated access to its elements.<\/Para><\/Abstract><Discussion><Para>A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let oneTwoThree = 1...3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for number in oneTwoThree {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var hasMosquito = false]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for bug in bugs {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if bug == \"Mosquito\" {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        hasMosquito = true]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        break]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(\"'bugs' has a mosquito: \\(hasMosquito)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"'bugs' has a mosquito: false\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Sequence<\/codeVoice> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s <codeVoice>contains(_:)<\/codeVoice> method, which every sequence inherits from <codeVoice>Sequence<\/codeVoice>, instead of iterating manually:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if bugs.contains(\"Mosquito\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Break out the bug spray.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Whew, no mosquitos!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Whew, no mosquitos!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Repeated Access<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>The <codeVoice>Sequence<\/codeVoice> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loops on a sequence will either resume iteration or restart from the beginning:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if ... some condition { break }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ No defined behavior]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><Para>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <codeVoice>Collection<\/codeVoice> protocol.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Sequence Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Making your own custom types conform to <codeVoice>Sequence<\/codeVoice> enables many useful operations, like <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> looping and the <codeVoice>contains<\/codeVoice> method, without much effort. To add <codeVoice>Sequence<\/codeVoice> conformance to your own custom type, add a <codeVoice>makeIterator()<\/codeVoice> method that returns an iterator.<\/Para><Para>Alternatively, if your type can act as its own iterator, implementing the requirements of the <codeVoice>IteratorProtocol<\/codeVoice> protocol and declaring conformance to both <codeVoice>Sequence<\/codeVoice> and <codeVoice>IteratorProtocol<\/codeVoice> are sufficient.<\/Para><Para>Here’s a definition of a <codeVoice>Countdown<\/codeVoice> sequence that serves as its own iterator. The <codeVoice>makeIterator()<\/codeVoice> method is provided as a default implementation.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[struct Countdown: Sequence, IteratorProtocol {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    var count: Int]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    mutating func next() -> Int? {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        if count == 0 {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return nil]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        } else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            defer { count -= 1 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return count]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let threeToGo = Countdown(count: 3)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in threeToGo {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(i)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A sequence should provide its iterator in O(1). The <codeVoice>Sequence<\/codeVoice> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<emphasis>n<\/emphasis>) unless documented otherwise.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Sequence",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Sequence<\/decl.name><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 194,
        "key.modulename" : "Swift",
        "key.name" : "Sequence",
        "key.namelength" : 8,
        "key.nameoffset" : 715,
        "key.offset" : 705,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var product: <Type usr=\"s:ST7ElementQa\">Element<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 820
              }
            ],
            "key.bodylength" : 47,
            "key.bodyoffset" : 849,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: Product of all values contained herein.",
            "key.doc.declaration" : "public var product: Element { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift\" line=\"33\" column=\"16\"><Name>product<\/Name><USR>s:ST7AlgebraAA14Multiplicative7ElementRpzrlE7productADvp<\/USR><Declaration>public var product: Element { get }<\/Declaration><CommentParts><ResultDiscussion><Para>Product of all values contained herein.<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 33,
            "key.doc.name" : "product",
            "key.doc.result_discussion" : [
              {
                "Para" : "Product of all values contained herein."
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 55,
            "key.docoffset" : 761,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>product<\/decl.name>: <decl.var.type><ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 70,
            "key.name" : "product",
            "key.namelength" : 7,
            "key.nameoffset" : 831,
            "key.offset" : 827,
            "key.parsed_declaration" : "public var product: Element",
            "key.parsed_scope.end" : 35,
            "key.parsed_scope.start" : 33,
            "key.typename" : "Self.Element",
            "key.typeusr" : "$S7ElementSTQzD",
            "key.usr" : "s:ST7AlgebraAA14Multiplicative7ElementRpzrlE7productADvp"
          }
        ],
        "key.typename" : "Sequence.Protocol",
        "key.typeusr" : "$SST_pmD",
        "key.usr" : "s:ST"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Collection : <Type usr=\"s:ST\">Sequence<\/Type> where <Type usr=\"s:Sl4Selfxmfp\">Self<\/Type>.SubSequence : <Type usr=\"s:Sl\">Collection<\/Type><\/Declaration>",
        "key.bodylength" : 157,
        "key.bodyoffset" : 956,
        "key.doc.declaration" : "protocol Collection : Sequence where Self.SubSequence : Collection",
        "key.doc.discussion" : [
          {
            "Para" : "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the `Collection` protocol declares and implements. In addition to the operations that collections inherit from the `Sequence` protocol, you gain access to methods that depend on accessing an element at a specific position in a collection."
          },
          {
            "Para" : "For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `firstSpace` constant is an index into the `text` string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, `firstSpace` is used to extract the prefix that contains elements up to that index."
          },
          {
            "Para" : "You can access an element of a collection through its subscript by using any valid index except the collection’s `endIndex` property. This property is a “past the end” index that does not correspond with any element of the collection."
          },
          {
            "Para" : "Here’s an example of accessing the first character in a string through its subscript:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Collection` protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of `text` using the `first` property, which has the value of the first element of the collection, or `nil` if the collection is empty."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s `startIndex` property and finding every successor up to, and including, the `endIndex` property. All other values of the `Index` type, such as the `startIndex` property of a different collection, are invalid indices for this collection."
          },
          {
            "Para" : "Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the `MutableCollection` and `RangeReplaceableCollection` protocols, as well as for the specific type you’re using."
          },
          {
            "Para" : "You can access a slice of a collection through its ranged subscript or by calling methods like `prefix(while:)` or `suffix(_:)`. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics."
          },
          {
            "Para" : "The following example creates a `firstWord` constant by using the `prefix(while:)` method to get a slice of the `text` string."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can retrieve the same slice using the string’s ranged subscript, which takes a range expression."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The retrieved slice of `text` is equivalent in each of these cases."
          },
          {
            "Para" : "A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created."
          },
          {
            "Para" : "For example, suppose you have an array holding the number of absences from each class during a session."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:"
          },
          {
            "List-Number" : ""
          },
          {
            "Para" : "Here’s an implementation of those steps:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice."
          },
          {
            "Para" : "For example, if you update the last element of the `absences` array from `0` to `2`, the `secondHalf` slice is unchanged."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Although a sequence can be consumed as it is traversed, a collection is guaranteed to be : Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the `contains(_:)` method to test whether a collection includes an element."
          },
          {
            "Para" : "Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the `characters` view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the `Collection` protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add `Collection` conformance to your type, you must declare at least the following requirements:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "Types that conform to `Collection` are expected to provide the `startIndex` and `endIndex` properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees."
          },
          {
            "Para" : "The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its `count` property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its `count` property is an O() operation."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Collection<\/Name><USR>s:Sl<\/USR><Declaration>protocol Collection : Sequence where Self.SubSequence : Collection<\/Declaration><CommentParts><Abstract><Para>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.<\/Para><\/Abstract><Discussion><Para>Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the <codeVoice>Collection<\/codeVoice> protocol declares and implements. In addition to the operations that collections inherit from the <codeVoice>Sequence<\/codeVoice> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.<\/Para><Para>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let text = \"Buffalo buffalo buffalo buffalo.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstSpace<\/codeVoice> constant is an index into the <codeVoice>text<\/codeVoice> string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, <codeVoice>firstSpace<\/codeVoice> is used to extract the prefix that contains elements up to that index.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Individual Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access an element of a collection through its subscript by using any valid index except the collection’s <codeVoice>endIndex<\/codeVoice> property. This property is a “past the end” index that does not correspond with any element of the collection.<\/Para><Para>Here’s an example of accessing the first character in a string through its subscript:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstChar = text[text.startIndex]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstChar)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"B\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Collection<\/codeVoice> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of <codeVoice>text<\/codeVoice> using the <codeVoice>first<\/codeVoice> property, which has the value of the first element of the collection, or <codeVoice>nil<\/codeVoice> if the collection is empty.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(text.first)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"B\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s <codeVoice>startIndex<\/codeVoice> property and finding every successor up to, and including, the <codeVoice>endIndex<\/codeVoice> property. All other values of the <codeVoice>Index<\/codeVoice> type, such as the <codeVoice>startIndex<\/codeVoice> property of a different collection, are invalid indices for this collection.<\/Para><Para>Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the <codeVoice>MutableCollection<\/codeVoice> and <codeVoice>RangeReplaceableCollection<\/codeVoice> protocols, as well as for the specific type you’re using.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Slices of a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access a slice of a collection through its ranged subscript or by calling methods like <codeVoice>prefix(while:)<\/codeVoice> or <codeVoice>suffix(_:)<\/codeVoice>. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.<\/Para><Para>The following example creates a <codeVoice>firstWord<\/codeVoice> constant by using the <codeVoice>prefix(while:)<\/codeVoice> method to get a slice of the <codeVoice>text<\/codeVoice> string.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstWord = text.prefix(while: { $0 != \" \" })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstWord)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The retrieved slice of <codeVoice>text<\/codeVoice> is equivalent in each of these cases.<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Share Indices<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.<\/Para><Para>For example, suppose you have an array holding the number of absences from each class during a session.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var absences = [0, 2, 0, 4, 0, 3, 1, 0]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:<\/Para><List-Number><Item><Para>Create a slice of the <codeVoice>absences<\/codeVoice> array that holds the second half of the days.<\/Para><\/Item><Item><Para>Use the <codeVoice>max(by:)<\/codeVoice> method to determine the index of the day with the most absences.<\/Para><\/Item><Item><Para>Print the result using the index found in step 2 on the original <codeVoice>absences<\/codeVoice> array.<\/Para><\/Item><\/List-Number><Para>Here’s an implementation of those steps:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let secondHalf = absences.suffix(absences.count \/ 2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Highest second-half absences: \\(absences[i])\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Highest second-half absences: 3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Inherit Collection Semantics<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.<\/Para><Para>For example, if you update the last element of the <codeVoice>absences<\/codeVoice> array from <codeVoice>0<\/codeVoice> to <codeVoice>2<\/codeVoice>, the <codeVoice>secondHalf<\/codeVoice> slice is unchanged.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[absences[7] = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(absences)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 2, 0, 4, 0, 3, 1, 2]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondHalf)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 3, 1, 0]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Traversing a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <emphasis>multipass<\/emphasis>: Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <codeVoice>contains(_:)<\/codeVoice> method to test whether a collection includes an element.<\/Para><Para>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the <codeVoice>characters<\/codeVoice> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let word = \"Swift\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for character in word {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(character)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in word.indices {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(word[i])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Collection Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <codeVoice>Collection<\/codeVoice> protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add <codeVoice>Collection<\/codeVoice> conformance to your type, you must declare at least the following requirements:<\/Para><List-Bullet><Item><Para>The <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties<\/Para><\/Item><Item><Para>A subscript that provides at least read-only access to your type’s elements<\/Para><\/Item><Item><Para>The <codeVoice>index(after:)<\/codeVoice> method for advancing an index into your collection<\/Para><\/Item><\/List-Bullet><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Types that conform to <codeVoice>Collection<\/codeVoice> are expected to provide the <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.<\/Para><Para>The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <codeVoice>count<\/codeVoice> property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <codeVoice>count<\/codeVoice> property is an O(<emphasis>n<\/emphasis>) operation.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Collection",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Collection<\/decl.name> : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement><ref.generic_type_param usr=\"s:Sl4Selfxmfp\">Self<\/ref.generic_type_param>.SubSequence : <ref.protocol usr=\"s:Sl\">Collection<\/ref.protocol><\/decl.generic_type_requirement><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 213,
        "key.modulename" : "Swift",
        "key.name" : "Collection",
        "key.namelength" : 10,
        "key.nameoffset" : 911,
        "key.offset" : 901,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var nonEmptySum: <Type usr=\"s:Sl8IteratorQa\">Iterator<\/Type>.<Type usr=\"s:St7ElementQa\">Element<\/Type>? { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 962
              }
            ],
            "key.bodylength" : 106,
            "key.bodyoffset" : 1005,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>nonEmptySum<\/decl.name>: <decl.var.type><ref.associatedtype usr=\"s:Sl8IteratorQa\">Iterator<\/ref.associatedtype>.<ref.associatedtype usr=\"s:St7ElementQa\">Element<\/ref.associatedtype>?<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 143,
            "key.name" : "nonEmptySum",
            "key.namelength" : 11,
            "key.nameoffset" : 973,
            "key.offset" : 969,
            "key.parsed_declaration" : "public var nonEmptySum: Iterator.Element?",
            "key.parsed_scope.end" : 43,
            "key.parsed_scope.start" : 40,
            "key.typename" : "Self.Element?",
            "key.typeusr" : "$S7ElementSTQzSgD",
            "key.usr" : "s:Sl7AlgebraAA17AdditiveSemigroup7ElementRpzrlE11nonEmptySumADSgvp"
          }
        ],
        "key.typename" : "Collection.Protocol",
        "key.typeusr" : "$SSl_pmD",
        "key.usr" : "s:Sl"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Collection : <Type usr=\"s:ST\">Sequence<\/Type> where <Type usr=\"s:Sl4Selfxmfp\">Self<\/Type>.SubSequence : <Type usr=\"s:Sl\">Collection<\/Type><\/Declaration>",
        "key.bodylength" : 161,
        "key.bodyoffset" : 1177,
        "key.doc.declaration" : "protocol Collection : Sequence where Self.SubSequence : Collection",
        "key.doc.discussion" : [
          {
            "Para" : "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the `Collection` protocol declares and implements. In addition to the operations that collections inherit from the `Sequence` protocol, you gain access to methods that depend on accessing an element at a specific position in a collection."
          },
          {
            "Para" : "For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `firstSpace` constant is an index into the `text` string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, `firstSpace` is used to extract the prefix that contains elements up to that index."
          },
          {
            "Para" : "You can access an element of a collection through its subscript by using any valid index except the collection’s `endIndex` property. This property is a “past the end” index that does not correspond with any element of the collection."
          },
          {
            "Para" : "Here’s an example of accessing the first character in a string through its subscript:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Collection` protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of `text` using the `first` property, which has the value of the first element of the collection, or `nil` if the collection is empty."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s `startIndex` property and finding every successor up to, and including, the `endIndex` property. All other values of the `Index` type, such as the `startIndex` property of a different collection, are invalid indices for this collection."
          },
          {
            "Para" : "Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the `MutableCollection` and `RangeReplaceableCollection` protocols, as well as for the specific type you’re using."
          },
          {
            "Para" : "You can access a slice of a collection through its ranged subscript or by calling methods like `prefix(while:)` or `suffix(_:)`. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics."
          },
          {
            "Para" : "The following example creates a `firstWord` constant by using the `prefix(while:)` method to get a slice of the `text` string."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can retrieve the same slice using the string’s ranged subscript, which takes a range expression."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The retrieved slice of `text` is equivalent in each of these cases."
          },
          {
            "Para" : "A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created."
          },
          {
            "Para" : "For example, suppose you have an array holding the number of absences from each class during a session."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:"
          },
          {
            "List-Number" : ""
          },
          {
            "Para" : "Here’s an implementation of those steps:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice."
          },
          {
            "Para" : "For example, if you update the last element of the `absences` array from `0` to `2`, the `secondHalf` slice is unchanged."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Although a sequence can be consumed as it is traversed, a collection is guaranteed to be : Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the `contains(_:)` method to test whether a collection includes an element."
          },
          {
            "Para" : "Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the `characters` view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the `Collection` protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add `Collection` conformance to your type, you must declare at least the following requirements:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "Types that conform to `Collection` are expected to provide the `startIndex` and `endIndex` properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees."
          },
          {
            "Para" : "The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its `count` property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its `count` property is an O() operation."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Collection<\/Name><USR>s:Sl<\/USR><Declaration>protocol Collection : Sequence where Self.SubSequence : Collection<\/Declaration><CommentParts><Abstract><Para>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.<\/Para><\/Abstract><Discussion><Para>Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the <codeVoice>Collection<\/codeVoice> protocol declares and implements. In addition to the operations that collections inherit from the <codeVoice>Sequence<\/codeVoice> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.<\/Para><Para>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let text = \"Buffalo buffalo buffalo buffalo.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstSpace<\/codeVoice> constant is an index into the <codeVoice>text<\/codeVoice> string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, <codeVoice>firstSpace<\/codeVoice> is used to extract the prefix that contains elements up to that index.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Individual Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access an element of a collection through its subscript by using any valid index except the collection’s <codeVoice>endIndex<\/codeVoice> property. This property is a “past the end” index that does not correspond with any element of the collection.<\/Para><Para>Here’s an example of accessing the first character in a string through its subscript:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstChar = text[text.startIndex]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstChar)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"B\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Collection<\/codeVoice> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of <codeVoice>text<\/codeVoice> using the <codeVoice>first<\/codeVoice> property, which has the value of the first element of the collection, or <codeVoice>nil<\/codeVoice> if the collection is empty.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(text.first)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"B\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s <codeVoice>startIndex<\/codeVoice> property and finding every successor up to, and including, the <codeVoice>endIndex<\/codeVoice> property. All other values of the <codeVoice>Index<\/codeVoice> type, such as the <codeVoice>startIndex<\/codeVoice> property of a different collection, are invalid indices for this collection.<\/Para><Para>Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the <codeVoice>MutableCollection<\/codeVoice> and <codeVoice>RangeReplaceableCollection<\/codeVoice> protocols, as well as for the specific type you’re using.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Slices of a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access a slice of a collection through its ranged subscript or by calling methods like <codeVoice>prefix(while:)<\/codeVoice> or <codeVoice>suffix(_:)<\/codeVoice>. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.<\/Para><Para>The following example creates a <codeVoice>firstWord<\/codeVoice> constant by using the <codeVoice>prefix(while:)<\/codeVoice> method to get a slice of the <codeVoice>text<\/codeVoice> string.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstWord = text.prefix(while: { $0 != \" \" })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstWord)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The retrieved slice of <codeVoice>text<\/codeVoice> is equivalent in each of these cases.<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Share Indices<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.<\/Para><Para>For example, suppose you have an array holding the number of absences from each class during a session.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var absences = [0, 2, 0, 4, 0, 3, 1, 0]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:<\/Para><List-Number><Item><Para>Create a slice of the <codeVoice>absences<\/codeVoice> array that holds the second half of the days.<\/Para><\/Item><Item><Para>Use the <codeVoice>max(by:)<\/codeVoice> method to determine the index of the day with the most absences.<\/Para><\/Item><Item><Para>Print the result using the index found in step 2 on the original <codeVoice>absences<\/codeVoice> array.<\/Para><\/Item><\/List-Number><Para>Here’s an implementation of those steps:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let secondHalf = absences.suffix(absences.count \/ 2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Highest second-half absences: \\(absences[i])\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Highest second-half absences: 3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Inherit Collection Semantics<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.<\/Para><Para>For example, if you update the last element of the <codeVoice>absences<\/codeVoice> array from <codeVoice>0<\/codeVoice> to <codeVoice>2<\/codeVoice>, the <codeVoice>secondHalf<\/codeVoice> slice is unchanged.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[absences[7] = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(absences)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 2, 0, 4, 0, 3, 1, 2]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondHalf)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 3, 1, 0]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Traversing a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <emphasis>multipass<\/emphasis>: Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <codeVoice>contains(_:)<\/codeVoice> method to test whether a collection includes an element.<\/Para><Para>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the <codeVoice>characters<\/codeVoice> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let word = \"Swift\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for character in word {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(character)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in word.indices {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(word[i])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Collection Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <codeVoice>Collection<\/codeVoice> protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add <codeVoice>Collection<\/codeVoice> conformance to your type, you must declare at least the following requirements:<\/Para><List-Bullet><Item><Para>The <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties<\/Para><\/Item><Item><Para>A subscript that provides at least read-only access to your type’s elements<\/Para><\/Item><Item><Para>The <codeVoice>index(after:)<\/codeVoice> method for advancing an index into your collection<\/Para><\/Item><\/List-Bullet><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Types that conform to <codeVoice>Collection<\/codeVoice> are expected to provide the <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.<\/Para><Para>The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <codeVoice>count<\/codeVoice> property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <codeVoice>count<\/codeVoice> property is an O(<emphasis>n<\/emphasis>) operation.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Collection",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Collection<\/decl.name> : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement><ref.generic_type_param usr=\"s:Sl4Selfxmfp\">Self<\/ref.generic_type_param>.SubSequence : <ref.protocol usr=\"s:Sl\">Collection<\/ref.protocol><\/decl.generic_type_requirement><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 223,
        "key.modulename" : "Swift",
        "key.name" : "Collection",
        "key.namelength" : 10,
        "key.nameoffset" : 1126,
        "key.offset" : 1116,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var nonEmptyProduct: <Type usr=\"s:Sl8IteratorQa\">Iterator<\/Type>.<Type usr=\"s:St7ElementQa\">Element<\/Type>? { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1183
              }
            ],
            "key.bodylength" : 106,
            "key.bodyoffset" : 1230,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>nonEmptyProduct<\/decl.name>: <decl.var.type><ref.associatedtype usr=\"s:Sl8IteratorQa\">Iterator<\/ref.associatedtype>.<ref.associatedtype usr=\"s:St7ElementQa\">Element<\/ref.associatedtype>?<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 147,
            "key.name" : "nonEmptyProduct",
            "key.namelength" : 15,
            "key.nameoffset" : 1194,
            "key.offset" : 1190,
            "key.parsed_declaration" : "public var nonEmptyProduct: Iterator.Element?",
            "key.parsed_scope.end" : 51,
            "key.parsed_scope.start" : 48,
            "key.typename" : "Self.Element?",
            "key.typeusr" : "$S7ElementSTQzSgD",
            "key.usr" : "s:Sl7AlgebraAA23MultiplicativeSemigroup7ElementRpzrlE15nonEmptyProductADSgvp"
          }
        ],
        "key.typename" : "Collection.Protocol",
        "key.typeusr" : "$SSl_pmD",
        "key.usr" : "s:Sl"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Sequence<\/Declaration>",
        "key.bodylength" : 131,
        "key.bodyoffset" : 1385,
        "key.doc.declaration" : "protocol Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a `for`-`in` loop:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s `contains(_:)` method, which every sequence inherits from `Sequence`, instead of iterating manually:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Sequence` protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple `for`-`in` loops on a sequence will either resume iteration or restart from the beginning:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second `for`-`in` loop."
          },
          {
            "Para" : "To establish that a type you’ve created supports nondestructive iteration, add conformance to the `Collection` protocol."
          },
          {
            "Para" : "Making your own custom types conform to `Sequence` enables many useful operations, like `for`-`in` looping and the `contains` method, without much effort. To add `Sequence` conformance to your own custom type, add a `makeIterator()` method that returns an iterator."
          },
          {
            "Para" : "Alternatively, if your type can act as its own iterator, implementing the requirements of the `IteratorProtocol` protocol and declaring conformance to both `Sequence` and `IteratorProtocol` are sufficient."
          },
          {
            "Para" : "Here’s a definition of a `Countdown` sequence that serves as its own iterator. The `makeIterator()` method is provided as a default implementation."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A sequence should provide its iterator in O(1). The `Sequence` protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O() unless documented otherwise."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Sequence<\/Name><USR>s:ST<\/USR><Declaration>protocol Sequence<\/Declaration><CommentParts><Abstract><Para>A type that provides sequential, iterated access to its elements.<\/Para><\/Abstract><Discussion><Para>A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let oneTwoThree = 1...3]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for number in oneTwoThree {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var hasMosquito = false]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for bug in bugs {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if bug == \"Mosquito\" {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        hasMosquito = true]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        break]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(\"'bugs' has a mosquito: \\(hasMosquito)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"'bugs' has a mosquito: false\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Sequence<\/codeVoice> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values. For clearer, more concise code, the example above could use the array’s <codeVoice>contains(_:)<\/codeVoice> method, which every sequence inherits from <codeVoice>Sequence<\/codeVoice>, instead of iterating manually:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if bugs.contains(\"Mosquito\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Break out the bug spray.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Whew, no mosquitos!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Whew, no mosquitos!\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Repeated Access<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>The <codeVoice>Sequence<\/codeVoice> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loops on a sequence will either resume iteration or restart from the beginning:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if ... some condition { break }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for element in sequence {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ No defined behavior]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><Para>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <codeVoice>Collection<\/codeVoice> protocol.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Sequence Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Making your own custom types conform to <codeVoice>Sequence<\/codeVoice> enables many useful operations, like <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> looping and the <codeVoice>contains<\/codeVoice> method, without much effort. To add <codeVoice>Sequence<\/codeVoice> conformance to your own custom type, add a <codeVoice>makeIterator()<\/codeVoice> method that returns an iterator.<\/Para><Para>Alternatively, if your type can act as its own iterator, implementing the requirements of the <codeVoice>IteratorProtocol<\/codeVoice> protocol and declaring conformance to both <codeVoice>Sequence<\/codeVoice> and <codeVoice>IteratorProtocol<\/codeVoice> are sufficient.<\/Para><Para>Here’s a definition of a <codeVoice>Countdown<\/codeVoice> sequence that serves as its own iterator. The <codeVoice>makeIterator()<\/codeVoice> method is provided as a default implementation.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[struct Countdown: Sequence, IteratorProtocol {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    var count: Int]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    mutating func next() -> Int? {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        if count == 0 {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return nil]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        } else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            defer { count -= 1 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[            return count]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let threeToGo = Countdown(count: 3)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in threeToGo {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(i)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>A sequence should provide its iterator in O(1). The <codeVoice>Sequence<\/codeVoice> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<emphasis>n<\/emphasis>) unless documented otherwise.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Sequence",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Sequence<\/decl.name><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 176,
        "key.modulename" : "Swift",
        "key.name" : "Sequence",
        "key.namelength" : 8,
        "key.nameoffset" : 1351,
        "key.offset" : 1341,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var sum: <Type usr=\"s:ST7ElementQa\">Element<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1446
              }
            ],
            "key.bodylength" : 43,
            "key.bodyoffset" : 1471,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: Sum of all values contained herein.",
            "key.doc.declaration" : "public var sum: Element { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift\" line=\"57\" column=\"16\"><Name>sum<\/Name><USR>s:ST7AlgebraAA8Additive7ElementRpzrlE3sumADvp<\/USR><Declaration>public var sum: Element { get }<\/Declaration><CommentParts><ResultDiscussion><Para>Sum of all values contained herein.<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 57,
            "key.doc.name" : "sum",
            "key.doc.result_discussion" : [
              {
                "Para" : "Sum of all values contained herein."
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 51,
            "key.docoffset" : 1391,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>sum<\/decl.name>: <decl.var.type><ref.associatedtype usr=\"s:ST7ElementQa\">Element<\/ref.associatedtype><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 62,
            "key.name" : "sum",
            "key.namelength" : 3,
            "key.nameoffset" : 1457,
            "key.offset" : 1453,
            "key.parsed_declaration" : "public var sum: Element",
            "key.parsed_scope.end" : 59,
            "key.parsed_scope.start" : 57,
            "key.typename" : "Self.Element",
            "key.typeusr" : "$S7ElementSTQzD",
            "key.usr" : "s:ST7AlgebraAA8Additive7ElementRpzrlE3sumADvp"
          }
        ],
        "key.typename" : "Sequence.Protocol",
        "key.typeusr" : "$SST_pmD",
        "key.usr" : "s:ST"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Set&lt;Element&gt; where Element : <Type usr=\"s:SH\">Hashable<\/Type><\/Declaration>",
        "key.bodylength" : 155,
        "key.bodyoffset" : 1544,
        "key.doc.declaration" : "struct Set<Element> where Element : Hashable",
        "key.doc.discussion" : [
          {
            "Para" : "You use a set instead of an array when you need to test efficiently for membership and you aren’t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection."
          },
          {
            "Para" : "You can create a set with any element type that conforms to the `Hashable` protocol. By default, most types in the standard library are hashable, including strings, numeric and Boolean types, enumeration cases without associated values, and even sets themselves."
          },
          {
            "Para" : "Swift makes it as easy to create a new set as to create a new array. Simply assign an array literal to a variable or constant with the `Set` type specified."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Sets provide a suite of mathematical set operations. For example, you can efficiently test a set for membership of an element or check its intersection with another set:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "You can also combine, exclude, or subtract the elements of two sets:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "You can modify a set in place by using these methods’ mutating counterparts: `formUnion(_:)`, `formIntersection(_:)`, `formSymmetricDifference(_:)`, and `subtract(_:)`."
          },
          {
            "Para" : "Set operations are not limited to use with other sets. Instead, you can perform set operations with another set, an array, or any other sequence type."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In addition to the `Set` type’s set operations, you can use any nonmutating sequence or collection methods with a set."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can iterate through a set’s unordered elements with a `for`-`in` loop."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Many sequence and collection operations return an array or a type-erasing collection wrapper instead of a set. To restore efficient set operations, create a new set from the result."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can bridge between `Set` and `NSSet` using the `as` operator. For bridging to be possible, the `Element` type of a set must be a class, an `@objc` protocol (a protocol imported from Objective-C or marked with the `@objc` attribute), or a type that bridges to a Foundation type."
          },
          {
            "Para" : "Bridging from `Set` to `NSSet` always takes O(1) time and space. When the set’s `Element` type is neither a class nor an `@objc` protocol, any required bridging of elements occurs at the first access of each element, so the first operation that uses the contents of the set (for example, a membership test) can take O()."
          },
          {
            "Para" : "Bridging from `NSSet` to `Set` first calls the `copy(with:)` method (`- copyWithZone:` in Objective-C) on the set to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of `NSSet` that are already immutable, `copy(with:)` returns the same set in constant time; otherwise, the copying performance is unspecified. The instances of `NSSet` and `Set` share buffer using the same copy-on-write optimization that is used when two instances of `Set` share buffer."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Set<\/Name><USR>s:Sh<\/USR><Declaration>struct Set&lt;Element&gt; where Element : Hashable<\/Declaration><CommentParts><Abstract><Para>An unordered collection of unique elements.<\/Para><\/Abstract><Discussion><Para>You use a set instead of an array when you need to test efficiently for membership and you aren’t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection.<\/Para><Para>You can create a set with any element type that conforms to the <codeVoice>Hashable<\/codeVoice> protocol. By default, most types in the standard library are hashable, including strings, numeric and Boolean types, enumeration cases without associated values, and even sets themselves.<\/Para><Para>Swift makes it as easy to create a new set as to create a new array. Simply assign an array literal to a variable or constant with the <codeVoice>Set<\/codeVoice> type specified.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if ingredients.contains(\"sugar\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"No thanks, too sweet.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"No thanks, too sweet.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Set Operations<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Sets provide a suite of mathematical set operations. For example, you can efficiently test a set for membership of an element or check its intersection with another set:<\/Para><List-Bullet><Item><Para>Use the <codeVoice>contains(_:)<\/codeVoice> method to test whether a set contains a specific element.<\/Para><\/Item><Item><Para>Use the “equal to” operator (<codeVoice>==<\/codeVoice>) to test whether two sets contain the same elements.<\/Para><\/Item><Item><Para>Use the <codeVoice>isSubset(of:)<\/codeVoice> method to test whether a set contains all the elements of another set or sequence.<\/Para><\/Item><Item><Para>Use the <codeVoice>isSuperset(of:)<\/codeVoice> method to test whether all elements of a set are contained in another set or sequence.<\/Para><\/Item><Item><Para>Use the <codeVoice>isStrictSubset(of:)<\/codeVoice> and <codeVoice>isStrictSuperset(of:)<\/codeVoice> methods to test whether a set is a subset or superset of, but not equal to, another set.<\/Para><\/Item><Item><Para>Use the <codeVoice>isDisjoint(with:)<\/codeVoice> method to test whether a set has any elements in common with another set.<\/Para><\/Item><\/List-Bullet><Para>You can also combine, exclude, or subtract the elements of two sets:<\/Para><List-Bullet><Item><Para>Use the <codeVoice>union(_:)<\/codeVoice> method to create a new set with the elements of a set and another set or sequence.<\/Para><\/Item><Item><Para>Use the <codeVoice>intersection(_:)<\/codeVoice> method to create a new set with only the elements common to a set and another set or sequence.<\/Para><\/Item><Item><Para>Use the <codeVoice>symmetricDifference(_:)<\/codeVoice> method to create a new set with the elements that are in either a set or another set or sequence, but not in both.<\/Para><\/Item><Item><Para>Use the <codeVoice>subtracting(_:)<\/codeVoice> method to create a new set with the elements of a set that are not also in another set or sequence.<\/Para><\/Item><\/List-Bullet><Para>You can modify a set in place by using these methods’ mutating counterparts: <codeVoice>formUnion(_:)<\/codeVoice>, <codeVoice>formIntersection(_:)<\/codeVoice>, <codeVoice>formSymmetricDifference(_:)<\/codeVoice>, and <codeVoice>subtract(_:)<\/codeVoice>.<\/Para><Para>Set operations are not limited to use with other sets. Instead, you can perform set operations with another set, an array, or any other sequence type.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var primes: Set = [2, 3, 5, 7]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Tests whether primes is a subset of a Range<Int>]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(primes.isSubset(of: 0..<10))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"true\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Performs an intersection with an Array<Int>]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let favoriteNumbers = [5, 7, 15, 21]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(primes.intersection(favoriteNumbers))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[5, 7]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Sequence and Collection Operations<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>In addition to the <codeVoice>Set<\/codeVoice> type’s set operations, you can use any nonmutating sequence or collection methods with a set.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if primes.isEmpty {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"No primes!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"We have \\(primes.count) primes.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"We have 4 primes.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let primesSum = primes.reduce(0, +)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'primesSum' == 17]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let primeStrings = primes.sorted().map(String.init)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'primeStrings' == [\"2\", \"3\", \"5\", \"7\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can iterate through a set’s unordered elements with a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for number in primes {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"5\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"7\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Many sequence and collection operations return an array or a type-erasing collection wrapper instead of a set. To restore efficient set operations, create a new set from the result.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let morePrimes = primes.union([11, 13, 17, 19])]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let laterPrimes = morePrimes.filter { $0 > 10 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'laterPrimes' is of type Array<Int>]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let laterPrimesSet = Set(morePrimes.filter { $0 > 10 })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'laterPrimesSet' is of type Set<Int>]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Bridging Between Set and NSSet<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can bridge between <codeVoice>Set<\/codeVoice> and <codeVoice>NSSet<\/codeVoice> using the <codeVoice>as<\/codeVoice> operator. For bridging to be possible, the <codeVoice>Element<\/codeVoice> type of a set must be a class, an <codeVoice>@objc<\/codeVoice> protocol (a protocol imported from Objective-C or marked with the <codeVoice>@objc<\/codeVoice> attribute), or a type that bridges to a Foundation type.<\/Para><Para>Bridging from <codeVoice>Set<\/codeVoice> to <codeVoice>NSSet<\/codeVoice> always takes O(1) time and space. When the set’s <codeVoice>Element<\/codeVoice> type is neither a class nor an <codeVoice>@objc<\/codeVoice> protocol, any required bridging of elements occurs at the first access of each element, so the first operation that uses the contents of the set (for example, a membership test) can take O(<emphasis>n<\/emphasis>).<\/Para><Para>Bridging from <codeVoice>NSSet<\/codeVoice> to <codeVoice>Set<\/codeVoice> first calls the <codeVoice>copy(with:)<\/codeVoice> method (<codeVoice>- copyWithZone:<\/codeVoice> in Objective-C) on the set to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of <codeVoice>NSSet<\/codeVoice> that are already immutable, <codeVoice>copy(with:)<\/codeVoice> returns the same set in constant time; otherwise, the copying performance is unspecified. The instances of <codeVoice>NSSet<\/codeVoice> and <codeVoice>Set<\/codeVoice> share buffer using the same copy-on-write optimization that is used when two instances of <codeVoice>Set<\/codeVoice> share buffer.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Set",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 8,
            "key.offset" : 1534
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Set<\/decl.name>&lt;<decl.generic_type_param usr=\"s:Sh7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element : <ref.protocol usr=\"s:SH\">Hashable<\/ref.protocol><\/decl.generic_type_requirement><\/decl.struct>",
        "key.groupname" : "Collection\/HashedCollections",
        "key.inheritedtypes" : [
          {
            "key.name" : "Additive"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 181,
        "key.modulename" : "Swift",
        "key.name" : "Set",
        "key.namelength" : 3,
        "key.nameoffset" : 1529,
        "key.offset" : 1519,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static var zero: <Type usr=\"s:Sh\">Set<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1550
              }
            ],
            "key.bodylength" : 26,
            "key.bodyoffset" : 1579,
            "key.doc.column" : 16,
            "key.doc.declaration" : "static var zero: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift\" line=\"13\" column=\"16\"><Name>zero<\/Name><USR>s:7Algebra4ZeroP4zeroxvpZ<\/USR><Declaration>static var zero: Self { get }<\/Declaration><CommentParts><Abstract><Para>Additive identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "zero",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>zero<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.static>",
            "key.groupname" : "Collection\/HashedCollections",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 49,
            "key.name" : "zero",
            "key.namelength" : 4,
            "key.nameoffset" : 1568,
            "key.offset" : 1557,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
              }
            ],
            "key.parsed_declaration" : "public static var zero: Set",
            "key.parsed_scope.end" : 66,
            "key.parsed_scope.start" : 64,
            "key.typename" : "Set<Element>",
            "key.typeusr" : "$SShyxGD",
            "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func + (lhs: <Type usr=\"s:Sh\">Set<\/Type>, rhs: <Type usr=\"s:Sh\">Set<\/Type>) -&gt; <Type usr=\"s:Sh\">Set<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1612
              }
            ],
            "key.bodylength" : 35,
            "key.bodyoffset" : 1662,
            "key.doc.column" : 17,
            "key.doc.declaration" : "static func + (lhs: Self, rhs: Self) -> Self",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AdditiveSemigroup.swift\" line=\"13\" column=\"17\"><Name>+(_:_:)<\/Name><USR>s:7Algebra17AdditiveSemigroupP1poiyxx_xtFZ<\/USR><Declaration>static func + (lhs: Self, rhs: Self) -&gt; Self<\/Declaration><CommentParts><Abstract><Para>Additive operation.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 13,
            "key.doc.name" : "+(_:_:)",
            "key.doc.type" : "Function",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>+ <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sh\">Set<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.groupname" : "Collection\/HashedCollections",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 79,
            "key.name" : "+(_:_:)",
            "key.namelength" : 22,
            "key.nameoffset" : 1631,
            "key.offset" : 1619,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra17AdditiveSemigroupP1poiyxx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func + (lhs: Set, rhs: Set) -> Set",
            "key.parsed_scope.end" : 70,
            "key.parsed_scope.start" : 68,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra17AdditiveSemigroupP1poiyxx_xtFZ\">+ (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SF1poiyxx_xtFZ\">+ (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sf1poiyS2f_SftFZ\">+ (_: Float, _: Float) -&gt; Float<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sd1poiyS2d_SdtFZ\">+ (_: Double, _: Double) -&gt; Double<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7Float80V1poiyA2B_ABtFZ\">+ (_: Float80, _: Float80) -&gt; Float80<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sj1poiyxx_xtFZ\">+ (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SjsE1popyxxFZ\">+(_:)<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sz1poiyxx_xtFZ\">+ (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V1poiyA2B_ABtFZ\">+ (_: UInt8, _: UInt8) -&gt; UInt8<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V1poiyA2B_ABtFZ\">+ (_: Int8, _: Int8) -&gt; Int8<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V1poiyA2B_ABtFZ\">+ (_: UInt16, _: UInt16) -&gt; UInt16<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V1poiyA2B_ABtFZ\">+ (_: Int16, _: Int16) -&gt; Int16<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V1poiyA2B_ABtFZ\">+ (_: UInt32, _: UInt32) -&gt; UInt32<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V1poiyA2B_ABtFZ\">+ (_: Int32, _: Int32) -&gt; Int32<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V1poiyA2B_ABtFZ\">+ (_: UInt64, _: UInt64) -&gt; UInt64<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V1poiyA2B_ABtFZ\">+ (_: Int64, _: Int64) -&gt; Int64<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su1poiyS2u_SutFZ\">+ (_: UInt, _: UInt) -&gt; UInt<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si1poiyS2i_SitFZ\">+ (_: Int, _: Int) -&gt; Int<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SmsE1poiyxx_qd__tSTRd__7ElementQyd__ABRtzlFZ\">+ &lt;Other&gt;(_: Self, _: Other) -&gt; Self where Other : Sequence, Self.Element == Other.Element<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SmsE1poiyxqd___xtSTRd__7ElementQyd__ABRtzlFZ\">+ &lt;Other&gt;(_: Other, _: Self) -&gt; Self where Other : Sequence, Self.Element == Other.Element<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SmsE1poiyxx_qd__tSmRd__7ElementQyd__ABRtzlFZ\">+ &lt;Other&gt;(_: Self, _: Other) -&gt; Self where Other : RangeReplaceableCollection, Self.Element == Other.Element<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sxss8_PointerRzrlE1poiyxx_6StrideSxQztFZ\">+ (_: Self, _: Self.Stride) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sxss8_PointerRzrlE1poiyx6StrideSxQz_xtFZ\">+ (_: Self.Stride, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS1poiyS2S_SStFZ\">+ (_: String, _: String) -&gt; String<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "<Element where Element : Hashable> (Set<Element>.Type) -> (Set<Element>, Set<Element>) -> Set<Element>",
            "key.typeusr" : "$SyShyxGAA_AAtcD",
            "key.usr" : "s:7Algebra17AdditiveSemigroupP1poiyxx_xtFZ"
          }
        ],
        "key.typename" : "Set<Element>.Type",
        "key.typeusr" : "$SShyxGmD",
        "key.usr" : "s:Sh"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Set&lt;Element&gt; where Element : <Type usr=\"s:SH\">Hashable<\/Type><\/Declaration>",
        "key.bodylength" : 100,
        "key.bodyoffset" : 1742,
        "key.doc.declaration" : "struct Set<Element> where Element : Hashable",
        "key.doc.discussion" : [
          {
            "Para" : "You use a set instead of an array when you need to test efficiently for membership and you aren’t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection."
          },
          {
            "Para" : "You can create a set with any element type that conforms to the `Hashable` protocol. By default, most types in the standard library are hashable, including strings, numeric and Boolean types, enumeration cases without associated values, and even sets themselves."
          },
          {
            "Para" : "Swift makes it as easy to create a new set as to create a new array. Simply assign an array literal to a variable or constant with the `Set` type specified."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Sets provide a suite of mathematical set operations. For example, you can efficiently test a set for membership of an element or check its intersection with another set:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "You can also combine, exclude, or subtract the elements of two sets:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "You can modify a set in place by using these methods’ mutating counterparts: `formUnion(_:)`, `formIntersection(_:)`, `formSymmetricDifference(_:)`, and `subtract(_:)`."
          },
          {
            "Para" : "Set operations are not limited to use with other sets. Instead, you can perform set operations with another set, an array, or any other sequence type."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In addition to the `Set` type’s set operations, you can use any nonmutating sequence or collection methods with a set."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can iterate through a set’s unordered elements with a `for`-`in` loop."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Many sequence and collection operations return an array or a type-erasing collection wrapper instead of a set. To restore efficient set operations, create a new set from the result."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can bridge between `Set` and `NSSet` using the `as` operator. For bridging to be possible, the `Element` type of a set must be a class, an `@objc` protocol (a protocol imported from Objective-C or marked with the `@objc` attribute), or a type that bridges to a Foundation type."
          },
          {
            "Para" : "Bridging from `Set` to `NSSet` always takes O(1) time and space. When the set’s `Element` type is neither a class nor an `@objc` protocol, any required bridging of elements occurs at the first access of each element, so the first operation that uses the contents of the set (for example, a membership test) can take O()."
          },
          {
            "Para" : "Bridging from `NSSet` to `Set` first calls the `copy(with:)` method (`- copyWithZone:` in Objective-C) on the set to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of `NSSet` that are already immutable, `copy(with:)` returns the same set in constant time; otherwise, the copying performance is unspecified. The instances of `NSSet` and `Set` share buffer using the same copy-on-write optimization that is used when two instances of `Set` share buffer."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Set<\/Name><USR>s:Sh<\/USR><Declaration>struct Set&lt;Element&gt; where Element : Hashable<\/Declaration><CommentParts><Abstract><Para>An unordered collection of unique elements.<\/Para><\/Abstract><Discussion><Para>You use a set instead of an array when you need to test efficiently for membership and you aren’t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection.<\/Para><Para>You can create a set with any element type that conforms to the <codeVoice>Hashable<\/codeVoice> protocol. By default, most types in the standard library are hashable, including strings, numeric and Boolean types, enumeration cases without associated values, and even sets themselves.<\/Para><Para>Swift makes it as easy to create a new set as to create a new array. Simply assign an array literal to a variable or constant with the <codeVoice>Set<\/codeVoice> type specified.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if ingredients.contains(\"sugar\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"No thanks, too sweet.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"No thanks, too sweet.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Set Operations<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Sets provide a suite of mathematical set operations. For example, you can efficiently test a set for membership of an element or check its intersection with another set:<\/Para><List-Bullet><Item><Para>Use the <codeVoice>contains(_:)<\/codeVoice> method to test whether a set contains a specific element.<\/Para><\/Item><Item><Para>Use the “equal to” operator (<codeVoice>==<\/codeVoice>) to test whether two sets contain the same elements.<\/Para><\/Item><Item><Para>Use the <codeVoice>isSubset(of:)<\/codeVoice> method to test whether a set contains all the elements of another set or sequence.<\/Para><\/Item><Item><Para>Use the <codeVoice>isSuperset(of:)<\/codeVoice> method to test whether all elements of a set are contained in another set or sequence.<\/Para><\/Item><Item><Para>Use the <codeVoice>isStrictSubset(of:)<\/codeVoice> and <codeVoice>isStrictSuperset(of:)<\/codeVoice> methods to test whether a set is a subset or superset of, but not equal to, another set.<\/Para><\/Item><Item><Para>Use the <codeVoice>isDisjoint(with:)<\/codeVoice> method to test whether a set has any elements in common with another set.<\/Para><\/Item><\/List-Bullet><Para>You can also combine, exclude, or subtract the elements of two sets:<\/Para><List-Bullet><Item><Para>Use the <codeVoice>union(_:)<\/codeVoice> method to create a new set with the elements of a set and another set or sequence.<\/Para><\/Item><Item><Para>Use the <codeVoice>intersection(_:)<\/codeVoice> method to create a new set with only the elements common to a set and another set or sequence.<\/Para><\/Item><Item><Para>Use the <codeVoice>symmetricDifference(_:)<\/codeVoice> method to create a new set with the elements that are in either a set or another set or sequence, but not in both.<\/Para><\/Item><Item><Para>Use the <codeVoice>subtracting(_:)<\/codeVoice> method to create a new set with the elements of a set that are not also in another set or sequence.<\/Para><\/Item><\/List-Bullet><Para>You can modify a set in place by using these methods’ mutating counterparts: <codeVoice>formUnion(_:)<\/codeVoice>, <codeVoice>formIntersection(_:)<\/codeVoice>, <codeVoice>formSymmetricDifference(_:)<\/codeVoice>, and <codeVoice>subtract(_:)<\/codeVoice>.<\/Para><Para>Set operations are not limited to use with other sets. Instead, you can perform set operations with another set, an array, or any other sequence type.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var primes: Set = [2, 3, 5, 7]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Tests whether primes is a subset of a Range<Int>]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(primes.isSubset(of: 0..<10))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"true\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Performs an intersection with an Array<Int>]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let favoriteNumbers = [5, 7, 15, 21]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(primes.intersection(favoriteNumbers))]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[5, 7]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Sequence and Collection Operations<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>In addition to the <codeVoice>Set<\/codeVoice> type’s set operations, you can use any nonmutating sequence or collection methods with a set.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if primes.isEmpty {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"No primes!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"We have \\(primes.count) primes.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"We have 4 primes.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let primesSum = primes.reduce(0, +)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'primesSum' == 17]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let primeStrings = primes.sorted().map(String.init)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'primeStrings' == [\"2\", \"3\", \"5\", \"7\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can iterate through a set’s unordered elements with a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for number in primes {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(number)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"5\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"7\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"2\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Many sequence and collection operations return an array or a type-erasing collection wrapper instead of a set. To restore efficient set operations, create a new set from the result.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let morePrimes = primes.union([11, 13, 17, 19])]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let laterPrimes = morePrimes.filter { $0 > 10 }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'laterPrimes' is of type Array<Int>]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let laterPrimesSet = Set(morePrimes.filter { $0 > 10 })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'laterPrimesSet' is of type Set<Int>]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Bridging Between Set and NSSet<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can bridge between <codeVoice>Set<\/codeVoice> and <codeVoice>NSSet<\/codeVoice> using the <codeVoice>as<\/codeVoice> operator. For bridging to be possible, the <codeVoice>Element<\/codeVoice> type of a set must be a class, an <codeVoice>@objc<\/codeVoice> protocol (a protocol imported from Objective-C or marked with the <codeVoice>@objc<\/codeVoice> attribute), or a type that bridges to a Foundation type.<\/Para><Para>Bridging from <codeVoice>Set<\/codeVoice> to <codeVoice>NSSet<\/codeVoice> always takes O(1) time and space. When the set’s <codeVoice>Element<\/codeVoice> type is neither a class nor an <codeVoice>@objc<\/codeVoice> protocol, any required bridging of elements occurs at the first access of each element, so the first operation that uses the contents of the set (for example, a membership test) can take O(<emphasis>n<\/emphasis>).<\/Para><Para>Bridging from <codeVoice>NSSet<\/codeVoice> to <codeVoice>Set<\/codeVoice> first calls the <codeVoice>copy(with:)<\/codeVoice> method (<codeVoice>- copyWithZone:<\/codeVoice> in Objective-C) on the set to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of <codeVoice>NSSet<\/codeVoice> that are already immutable, <codeVoice>copy(with:)<\/codeVoice> returns the same set in constant time; otherwise, the copying performance is unspecified. The instances of <codeVoice>NSSet<\/codeVoice> and <codeVoice>Set<\/codeVoice> share buffer using the same copy-on-write optimization that is used when two instances of <codeVoice>Set<\/codeVoice> share buffer.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Set",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 23,
            "key.offset" : 1717
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Set<\/decl.name>&lt;<decl.generic_type_param usr=\"s:Sh7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element : <ref.protocol usr=\"s:SH\">Hashable<\/ref.protocol><\/decl.generic_type_requirement><\/decl.struct>",
        "key.groupname" : "Collection\/HashedCollections",
        "key.inheritedtypes" : [
          {
            "key.name" : "MultiplicativeSemigroup"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 141,
        "key.modulename" : "Swift",
        "key.name" : "Set",
        "key.namelength" : 3,
        "key.nameoffset" : 1712,
        "key.offset" : 1702,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func * (lhs: <Type usr=\"s:Sh\">Set<\/Type>, rhs: <Type usr=\"s:Sh\">Set<\/Type>) -&gt; <Type usr=\"s:Sh\">Set<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1748
              }
            ],
            "key.bodylength" : 42,
            "key.bodyoffset" : 1798,
            "key.doc.column" : 17,
            "key.doc.declaration" : "static func * (lhs: Self, rhs: Self) -> Self",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift\" line=\"13\" column=\"17\"><Name>*(_:_:)<\/Name><USR>s:7Algebra23MultiplicativeSemigroupP1moiyxx_xtFZ<\/USR><Declaration>static func * (lhs: Self, rhs: Self) -&gt; Self<\/Declaration><CommentParts><Abstract><Para>Multiplicative operation.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 13,
            "key.doc.name" : "*(_:_:)",
            "key.doc.type" : "Function",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>* <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sh\">Set<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.groupname" : "Collection\/HashedCollections",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 86,
            "key.name" : "*(_:_:)",
            "key.namelength" : 22,
            "key.nameoffset" : 1767,
            "key.offset" : 1755,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra23MultiplicativeSemigroupP1moiyxx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func * (lhs: Set, rhs: Set) -> Set",
            "key.parsed_scope.end" : 77,
            "key.parsed_scope.start" : 75,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra23MultiplicativeSemigroupP1moiyxx_xtFZ\">* (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SF1moiyxx_xtFZ\">* (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sf1moiyS2f_SftFZ\">* (_: Float, _: Float) -&gt; Float<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sd1moiyS2d_SdtFZ\">* (_: Double, _: Double) -&gt; Double<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7Float80V1moiyA2B_ABtFZ\">* (_: Float80, _: Float80) -&gt; Float80<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sj1moiyxx_xtFZ\">* (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sz1moiyxx_xtFZ\">* (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V1moiyA2B_ABtFZ\">* (_: UInt8, _: UInt8) -&gt; UInt8<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V1moiyA2B_ABtFZ\">* (_: Int8, _: Int8) -&gt; Int8<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V1moiyA2B_ABtFZ\">* (_: UInt16, _: UInt16) -&gt; UInt16<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V1moiyA2B_ABtFZ\">* (_: Int16, _: Int16) -&gt; Int16<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V1moiyA2B_ABtFZ\">* (_: UInt32, _: UInt32) -&gt; UInt32<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V1moiyA2B_ABtFZ\">* (_: Int32, _: Int32) -&gt; Int32<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V1moiyA2B_ABtFZ\">* (_: UInt64, _: UInt64) -&gt; UInt64<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V1moiyA2B_ABtFZ\">* (_: Int64, _: Int64) -&gt; Int64<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su1moiyS2u_SutFZ\">* (_: UInt, _: UInt) -&gt; UInt<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si1moiyS2i_SitFZ\">* (_: Int, _: Int) -&gt; Int<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "<Element where Element : Hashable> (Set<Element>.Type) -> (Set<Element>, Set<Element>) -> Set<Element>",
            "key.typeusr" : "$SyShyxGAA_AAtcD",
            "key.usr" : "s:7Algebra23MultiplicativeSemigroupP1moiyxx_xtFZ"
          }
        ],
        "key.typename" : "Set<Element>.Type",
        "key.typeusr" : "$SShyxGmD",
        "key.usr" : "s:Sh"
      },
      {
        "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
        "key.length" : 19,
        "key.name" : "MARK: numeric types",
        "key.namelength" : 0,
        "key.nameoffset" : 0,
        "key.offset" : 1850
      },
      {
        "key.annotated_decl" : "<Declaration>struct Int : <Type usr=\"s:s17FixedWidthIntegerP\">FixedWidthInteger<\/Type>, <Type usr=\"s:SZ\">SignedInteger<\/Type><\/Declaration>",
        "key.bodylength" : 37,
        "key.bodyoffset" : 1905,
        "key.doc.declaration" : "struct Int : FixedWidthInteger, SignedInteger",
        "key.doc.discussion" : [
          {
            "Para" : "On 32-bit platforms, `Int` is the same size as `Int32`, and on 64-bit platforms, `Int` is the same size as `Int64`."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Int<\/Name><USR>s:Si<\/USR><Declaration>struct Int : FixedWidthInteger, SignedInteger<\/Declaration><CommentParts><Abstract><Para>A signed integer value type.<\/Para><\/Abstract><Discussion><Para>On 32-bit platforms, <codeVoice>Int<\/codeVoice> is the same size as <codeVoice>Int32<\/codeVoice>, and on 64-bit platforms, <codeVoice>Int<\/codeVoice> is the same size as <codeVoice>Int64<\/codeVoice>.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Int",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 17,
            "key.offset" : 1886
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Int<\/decl.name> : <ref.protocol usr=\"s:s17FixedWidthIntegerP\">FixedWidthInteger<\/ref.protocol>, <ref.protocol usr=\"s:SZ\">SignedInteger<\/ref.protocol><\/decl.struct>",
        "key.groupname" : "Math\/Integers",
        "key.inheritedtypes" : [
          {
            "key.name" : "AdditiveSemigroup"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 72,
        "key.modulename" : "Swift",
        "key.name" : "Int",
        "key.namelength" : 3,
        "key.nameoffset" : 1881,
        "key.offset" : 1871,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static let zero: <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1910
              }
            ],
            "key.doc.column" : 16,
            "key.doc.declaration" : "static var zero: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift\" line=\"13\" column=\"16\"><Name>zero<\/Name><USR>s:7Algebra4ZeroP4zeroxvpZ<\/USR><Declaration>static var zero: Self { get }<\/Declaration><CommentParts><Abstract><Para>Additive identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "zero",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>zero<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.type><\/decl.var.static>",
            "key.groupname" : "Math\/Integers",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 24,
            "key.name" : "zero",
            "key.namelength" : 4,
            "key.nameoffset" : 1928,
            "key.offset" : 1917,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
              }
            ],
            "key.parsed_declaration" : "public static let zero: Int = 0",
            "key.parsed_scope.end" : 83,
            "key.parsed_scope.start" : 83,
            "key.typename" : "Int",
            "key.typeusr" : "$SSiD",
            "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
          }
        ],
        "key.typename" : "Int.Type",
        "key.typeusr" : "$SSimD",
        "key.usr" : "s:Si"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Int : <Type usr=\"s:s17FixedWidthIntegerP\">FixedWidthInteger<\/Type>, <Type usr=\"s:SZ\">SignedInteger<\/Type><\/Declaration>",
        "key.bodylength" : 1,
        "key.bodyoffset" : 1970,
        "key.doc.declaration" : "struct Int : FixedWidthInteger, SignedInteger",
        "key.doc.discussion" : [
          {
            "Para" : "On 32-bit platforms, `Int` is the same size as `Int32`, and on 64-bit platforms, `Int` is the same size as `Int64`."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Int<\/Name><USR>s:Si<\/USR><Declaration>struct Int : FixedWidthInteger, SignedInteger<\/Declaration><CommentParts><Abstract><Para>A signed integer value type.<\/Para><\/Abstract><Discussion><Para>On 32-bit platforms, <codeVoice>Int<\/codeVoice> is the same size as <codeVoice>Int32<\/codeVoice>, and on 64-bit platforms, <codeVoice>Int<\/codeVoice> is the same size as <codeVoice>Int64<\/codeVoice>.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Int",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 8,
            "key.offset" : 1960
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Int<\/decl.name> : <ref.protocol usr=\"s:s17FixedWidthIntegerP\">FixedWidthInteger<\/ref.protocol>, <ref.protocol usr=\"s:SZ\">SignedInteger<\/ref.protocol><\/decl.struct>",
        "key.groupname" : "Math\/Integers",
        "key.inheritedtypes" : [
          {
            "key.name" : "Additive"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 27,
        "key.modulename" : "Swift",
        "key.name" : "Int",
        "key.namelength" : 3,
        "key.nameoffset" : 1955,
        "key.offset" : 1945,
        "key.typename" : "Int.Type",
        "key.typeusr" : "$SSimD",
        "key.usr" : "s:Si"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Int : <Type usr=\"s:s17FixedWidthIntegerP\">FixedWidthInteger<\/Type>, <Type usr=\"s:SZ\">SignedInteger<\/Type><\/Declaration>",
        "key.bodylength" : 36,
        "key.bodyoffset" : 2014,
        "key.doc.declaration" : "struct Int : FixedWidthInteger, SignedInteger",
        "key.doc.discussion" : [
          {
            "Para" : "On 32-bit platforms, `Int` is the same size as `Int32`, and on 64-bit platforms, `Int` is the same size as `Int64`."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Int<\/Name><USR>s:Si<\/USR><Declaration>struct Int : FixedWidthInteger, SignedInteger<\/Declaration><CommentParts><Abstract><Para>A signed integer value type.<\/Para><\/Abstract><Discussion><Para>On 32-bit platforms, <codeVoice>Int<\/codeVoice> is the same size as <codeVoice>Int32<\/codeVoice>, and on 64-bit platforms, <codeVoice>Int<\/codeVoice> is the same size as <codeVoice>Int64<\/codeVoice>.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Int",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 23,
            "key.offset" : 1989
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Int<\/decl.name> : <ref.protocol usr=\"s:s17FixedWidthIntegerP\">FixedWidthInteger<\/ref.protocol>, <ref.protocol usr=\"s:SZ\">SignedInteger<\/ref.protocol><\/decl.struct>",
        "key.groupname" : "Math\/Integers",
        "key.inheritedtypes" : [
          {
            "key.name" : "MultiplicativeSemigroup"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 77,
        "key.modulename" : "Swift",
        "key.name" : "Int",
        "key.namelength" : 3,
        "key.nameoffset" : 1984,
        "key.offset" : 1974,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static let one: <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2019
              }
            ],
            "key.doc.column" : 16,
            "key.doc.declaration" : "static var one: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift\" line=\"13\" column=\"16\"><Name>one<\/Name><USR>s:7Algebra3OneP3onexvpZ<\/USR><Declaration>static var one: Self { get }<\/Declaration><CommentParts><Abstract><Para>Multiplicative identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "one",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>one<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.type><\/decl.var.static>",
            "key.groupname" : "Math\/Integers",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 23,
            "key.name" : "one",
            "key.namelength" : 3,
            "key.nameoffset" : 2037,
            "key.offset" : 2026,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra3OneP3onexvpZ"
              }
            ],
            "key.parsed_declaration" : "public static let one: Int = 1",
            "key.parsed_scope.end" : 89,
            "key.parsed_scope.start" : 89,
            "key.typename" : "Int",
            "key.typeusr" : "$SSiD",
            "key.usr" : "s:7Algebra3OneP3onexvpZ"
          }
        ],
        "key.typename" : "Int.Type",
        "key.typeusr" : "$SSimD",
        "key.usr" : "s:Si"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Int : <Type usr=\"s:s17FixedWidthIntegerP\">FixedWidthInteger<\/Type>, <Type usr=\"s:SZ\">SignedInteger<\/Type><\/Declaration>",
        "key.bodylength" : 1,
        "key.bodyoffset" : 2084,
        "key.doc.declaration" : "struct Int : FixedWidthInteger, SignedInteger",
        "key.doc.discussion" : [
          {
            "Para" : "On 32-bit platforms, `Int` is the same size as `Int32`, and on 64-bit platforms, `Int` is the same size as `Int64`."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Int<\/Name><USR>s:Si<\/USR><Declaration>struct Int : FixedWidthInteger, SignedInteger<\/Declaration><CommentParts><Abstract><Para>A signed integer value type.<\/Para><\/Abstract><Discussion><Para>On 32-bit platforms, <codeVoice>Int<\/codeVoice> is the same size as <codeVoice>Int32<\/codeVoice>, and on 64-bit platforms, <codeVoice>Int<\/codeVoice> is the same size as <codeVoice>Int64<\/codeVoice>.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Int",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 14,
            "key.offset" : 2068
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Int<\/decl.name> : <ref.protocol usr=\"s:s17FixedWidthIntegerP\">FixedWidthInteger<\/ref.protocol>, <ref.protocol usr=\"s:SZ\">SignedInteger<\/ref.protocol><\/decl.struct>",
        "key.groupname" : "Math\/Integers",
        "key.inheritedtypes" : [
          {
            "key.name" : "Multiplicative"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 33,
        "key.modulename" : "Swift",
        "key.name" : "Int",
        "key.namelength" : 3,
        "key.nameoffset" : 2063,
        "key.offset" : 2053,
        "key.typename" : "Int.Type",
        "key.typeusr" : "$SSimD",
        "key.usr" : "s:Si"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Float<\/Declaration>",
        "key.bodylength" : 39,
        "key.bodyoffset" : 2124,
        "key.doc.declaration" : "struct Float",
        "key.doc.full_as_xml" : "<Class><Name>Float<\/Name><USR>s:Sf<\/USR><Declaration>struct Float<\/Declaration><CommentParts><Abstract><Para>A single-precision, floating-point value type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.name" : "Float",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 17,
            "key.offset" : 2105
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Float<\/decl.name><\/decl.struct>",
        "key.groupname" : "Math\/Floating",
        "key.inheritedtypes" : [
          {
            "key.name" : "AdditiveSemigroup"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 76,
        "key.modulename" : "Swift",
        "key.name" : "Float",
        "key.namelength" : 5,
        "key.nameoffset" : 2098,
        "key.offset" : 2088,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static let zero: <Type usr=\"s:Sf\">Float<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2129
              }
            ],
            "key.doc.column" : 16,
            "key.doc.declaration" : "static var zero: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift\" line=\"13\" column=\"16\"><Name>zero<\/Name><USR>s:7Algebra4ZeroP4zeroxvpZ<\/USR><Declaration>static var zero: Self { get }<\/Declaration><CommentParts><Abstract><Para>Additive identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "zero",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>zero<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sf\">Float<\/ref.struct><\/decl.var.type><\/decl.var.static>",
            "key.groupname" : "Math\/Floating",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 26,
            "key.name" : "zero",
            "key.namelength" : 4,
            "key.nameoffset" : 2147,
            "key.offset" : 2136,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
              }
            ],
            "key.parsed_declaration" : "public static let zero: Float = 0",
            "key.parsed_scope.end" : 95,
            "key.parsed_scope.start" : 95,
            "key.typename" : "Float",
            "key.typeusr" : "$SSfD",
            "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
          }
        ],
        "key.typename" : "Float.Type",
        "key.typeusr" : "$SSfmD",
        "key.usr" : "s:Sf"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Float<\/Declaration>",
        "key.bodylength" : 1,
        "key.bodyoffset" : 2193,
        "key.doc.declaration" : "struct Float",
        "key.doc.full_as_xml" : "<Class><Name>Float<\/Name><USR>s:Sf<\/USR><Declaration>struct Float<\/Declaration><CommentParts><Abstract><Para>A single-precision, floating-point value type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.name" : "Float",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 8,
            "key.offset" : 2183
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Float<\/decl.name><\/decl.struct>",
        "key.groupname" : "Math\/Floating",
        "key.inheritedtypes" : [
          {
            "key.name" : "Additive"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 29,
        "key.modulename" : "Swift",
        "key.name" : "Float",
        "key.namelength" : 5,
        "key.nameoffset" : 2176,
        "key.offset" : 2166,
        "key.typename" : "Float.Type",
        "key.typeusr" : "$SSfmD",
        "key.usr" : "s:Sf"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Float<\/Declaration>",
        "key.bodylength" : 38,
        "key.bodyoffset" : 2239,
        "key.doc.declaration" : "struct Float",
        "key.doc.full_as_xml" : "<Class><Name>Float<\/Name><USR>s:Sf<\/USR><Declaration>struct Float<\/Declaration><CommentParts><Abstract><Para>A single-precision, floating-point value type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.name" : "Float",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 23,
            "key.offset" : 2214
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Float<\/decl.name><\/decl.struct>",
        "key.groupname" : "Math\/Floating",
        "key.inheritedtypes" : [
          {
            "key.name" : "MultiplicativeSemigroup"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 81,
        "key.modulename" : "Swift",
        "key.name" : "Float",
        "key.namelength" : 5,
        "key.nameoffset" : 2207,
        "key.offset" : 2197,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static let one: <Type usr=\"s:Sf\">Float<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2244
              }
            ],
            "key.doc.column" : 16,
            "key.doc.declaration" : "static var one: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift\" line=\"13\" column=\"16\"><Name>one<\/Name><USR>s:7Algebra3OneP3onexvpZ<\/USR><Declaration>static var one: Self { get }<\/Declaration><CommentParts><Abstract><Para>Multiplicative identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "one",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>one<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sf\">Float<\/ref.struct><\/decl.var.type><\/decl.var.static>",
            "key.groupname" : "Math\/Floating",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 25,
            "key.name" : "one",
            "key.namelength" : 3,
            "key.nameoffset" : 2262,
            "key.offset" : 2251,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra3OneP3onexvpZ"
              }
            ],
            "key.parsed_declaration" : "public static let one: Float = 1",
            "key.parsed_scope.end" : 101,
            "key.parsed_scope.start" : 101,
            "key.typename" : "Float",
            "key.typeusr" : "$SSfD",
            "key.usr" : "s:7Algebra3OneP3onexvpZ"
          }
        ],
        "key.typename" : "Float.Type",
        "key.typeusr" : "$SSfmD",
        "key.usr" : "s:Sf"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Float<\/Declaration>",
        "key.bodylength" : 1,
        "key.bodyoffset" : 2313,
        "key.doc.declaration" : "struct Float",
        "key.doc.full_as_xml" : "<Class><Name>Float<\/Name><USR>s:Sf<\/USR><Declaration>struct Float<\/Declaration><CommentParts><Abstract><Para>A single-precision, floating-point value type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.name" : "Float",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 14,
            "key.offset" : 2297
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Float<\/decl.name><\/decl.struct>",
        "key.groupname" : "Math\/Floating",
        "key.inheritedtypes" : [
          {
            "key.name" : "Multiplicative"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 35,
        "key.modulename" : "Swift",
        "key.name" : "Float",
        "key.namelength" : 5,
        "key.nameoffset" : 2290,
        "key.offset" : 2280,
        "key.typename" : "Float.Type",
        "key.typeusr" : "$SSfmD",
        "key.usr" : "s:Sf"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Double<\/Declaration>",
        "key.bodylength" : 40,
        "key.bodyoffset" : 2354,
        "key.doc.declaration" : "struct Double",
        "key.doc.full_as_xml" : "<Class><Name>Double<\/Name><USR>s:Sd<\/USR><Declaration>struct Double<\/Declaration><CommentParts><Abstract><Para>A double-precision, floating-point value type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.name" : "Double",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 17,
            "key.offset" : 2335
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Double<\/decl.name><\/decl.struct>",
        "key.groupname" : "Math\/Floating",
        "key.inheritedtypes" : [
          {
            "key.name" : "AdditiveSemigroup"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 78,
        "key.modulename" : "Swift",
        "key.name" : "Double",
        "key.namelength" : 6,
        "key.nameoffset" : 2327,
        "key.offset" : 2317,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static let zero: <Type usr=\"s:Sd\">Double<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2359
              }
            ],
            "key.doc.column" : 16,
            "key.doc.declaration" : "static var zero: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift\" line=\"13\" column=\"16\"><Name>zero<\/Name><USR>s:7Algebra4ZeroP4zeroxvpZ<\/USR><Declaration>static var zero: Self { get }<\/Declaration><CommentParts><Abstract><Para>Additive identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "zero",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>zero<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sd\">Double<\/ref.struct><\/decl.var.type><\/decl.var.static>",
            "key.groupname" : "Math\/Floating",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 27,
            "key.name" : "zero",
            "key.namelength" : 4,
            "key.nameoffset" : 2377,
            "key.offset" : 2366,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
              }
            ],
            "key.parsed_declaration" : "public static let zero: Double = 0",
            "key.parsed_scope.end" : 107,
            "key.parsed_scope.start" : 107,
            "key.typename" : "Double",
            "key.typeusr" : "$SSdD",
            "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
          }
        ],
        "key.typename" : "Double.Type",
        "key.typeusr" : "$SSdmD",
        "key.usr" : "s:Sd"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Double<\/Declaration>",
        "key.bodylength" : 1,
        "key.bodyoffset" : 2425,
        "key.doc.declaration" : "struct Double",
        "key.doc.full_as_xml" : "<Class><Name>Double<\/Name><USR>s:Sd<\/USR><Declaration>struct Double<\/Declaration><CommentParts><Abstract><Para>A double-precision, floating-point value type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.name" : "Double",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 8,
            "key.offset" : 2415
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Double<\/decl.name><\/decl.struct>",
        "key.groupname" : "Math\/Floating",
        "key.inheritedtypes" : [
          {
            "key.name" : "Additive"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 30,
        "key.modulename" : "Swift",
        "key.name" : "Double",
        "key.namelength" : 6,
        "key.nameoffset" : 2407,
        "key.offset" : 2397,
        "key.typename" : "Double.Type",
        "key.typeusr" : "$SSdmD",
        "key.usr" : "s:Sd"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Double<\/Declaration>",
        "key.bodylength" : 39,
        "key.bodyoffset" : 2472,
        "key.doc.declaration" : "struct Double",
        "key.doc.full_as_xml" : "<Class><Name>Double<\/Name><USR>s:Sd<\/USR><Declaration>struct Double<\/Declaration><CommentParts><Abstract><Para>A double-precision, floating-point value type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.name" : "Double",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 23,
            "key.offset" : 2447
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Double<\/decl.name><\/decl.struct>",
        "key.groupname" : "Math\/Floating",
        "key.inheritedtypes" : [
          {
            "key.name" : "MultiplicativeSemigroup"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 83,
        "key.modulename" : "Swift",
        "key.name" : "Double",
        "key.namelength" : 6,
        "key.nameoffset" : 2439,
        "key.offset" : 2429,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static let one: <Type usr=\"s:Sd\">Double<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2477
              }
            ],
            "key.doc.column" : 16,
            "key.doc.declaration" : "static var one: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift\" line=\"13\" column=\"16\"><Name>one<\/Name><USR>s:7Algebra3OneP3onexvpZ<\/USR><Declaration>static var one: Self { get }<\/Declaration><CommentParts><Abstract><Para>Multiplicative identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "one",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/AlgebraAdapters.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>one<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sd\">Double<\/ref.struct><\/decl.var.type><\/decl.var.static>",
            "key.groupname" : "Math\/Floating",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 26,
            "key.name" : "one",
            "key.namelength" : 3,
            "key.nameoffset" : 2495,
            "key.offset" : 2484,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra3OneP3onexvpZ"
              }
            ],
            "key.parsed_declaration" : "public static let one: Double = 1",
            "key.parsed_scope.end" : 113,
            "key.parsed_scope.start" : 113,
            "key.typename" : "Double",
            "key.typeusr" : "$SSdD",
            "key.usr" : "s:7Algebra3OneP3onexvpZ"
          }
        ],
        "key.typename" : "Double.Type",
        "key.typeusr" : "$SSdmD",
        "key.usr" : "s:Sd"
      },
      {
        "key.annotated_decl" : "<Declaration>struct Double<\/Declaration>",
        "key.bodylength" : 1,
        "key.bodyoffset" : 2548,
        "key.doc.declaration" : "struct Double",
        "key.doc.full_as_xml" : "<Class><Name>Double<\/Name><USR>s:Sd<\/USR><Declaration>struct Double<\/Declaration><CommentParts><Abstract><Para>A double-precision, floating-point value type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.name" : "Double",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 14,
            "key.offset" : 2532
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Double<\/decl.name><\/decl.struct>",
        "key.groupname" : "Math\/Floating",
        "key.inheritedtypes" : [
          {
            "key.name" : "Multiplicative"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 36,
        "key.modulename" : "Swift",
        "key.name" : "Double",
        "key.namelength" : 6,
        "key.nameoffset" : 2524,
        "key.offset" : 2514,
        "key.typename" : "Double.Type",
        "key.typeusr" : "$SSdmD",
        "key.usr" : "s:Sd"
      },
      {
        "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
        "key.length" : 16,
        "key.name" : "FIXME: Flesh out",
        "key.namelength" : 0,
        "key.nameoffset" : 0,
        "key.offset" : 2555
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Group.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 268,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol Group : <Type usr=\"s:7Algebra10InvertibleP\">Invertible<\/Type>, <Type usr=\"s:7Algebra6MonoidP\">Monoid<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 222
          }
        ],
        "key.bodylength" : 1,
        "key.bodyoffset" : 265,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface defining objects which operate as a group. `Group` extends the requirements of\n`Monoid` by adding the `Invertible` requirement.",
        "key.doc.declaration" : "public protocol Group : Invertible, Monoid",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Group.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Group.swift\" line=\"10\" column=\"17\"><Name>Group<\/Name><USR>s:7Algebra5GroupP<\/USR><Declaration>public protocol Group : Invertible, Monoid<\/Declaration><CommentParts><Abstract><Para>Interface defining objects which operate as a group. <codeVoice>Group<\/codeVoice> extends the requirements of <codeVoice>Monoid<\/codeVoice> by adding the <codeVoice>Invertible<\/codeVoice> requirement.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "Group",
        "key.doc.type" : "Class",
        "key.doclength" : 146,
        "key.docoffset" : 76,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 6,
            "key.offset" : 245
          },
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 10,
            "key.offset" : 253
          }
        ],
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Group.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Group<\/decl.name> : <ref.protocol usr=\"s:7Algebra10InvertibleP\">Invertible<\/ref.protocol>, <ref.protocol usr=\"s:7Algebra6MonoidP\">Monoid<\/ref.protocol><\/decl.protocol>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Monoid"
          },
          {
            "key.name" : "Invertible"
          }
        ],
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 38,
        "key.name" : "Group",
        "key.namelength" : 5,
        "key.nameoffset" : 238,
        "key.offset" : 229,
        "key.parsed_declaration" : "public protocol Group: Monoid, Invertible",
        "key.parsed_scope.end" : 10,
        "key.parsed_scope.start" : 10,
        "key.runtime_name" : "_TtP5Group5Group_",
        "key.typename" : "Group.Protocol",
        "key.typeusr" : "$S7Algebra5Group_pmD",
        "key.usr" : "s:7Algebra5GroupP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Invertible.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 189,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol Invertible<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 128
          }
        ],
        "key.bodylength" : 31,
        "key.bodyoffset" : 156,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface for types which have an inverse.",
        "key.doc.declaration" : "public protocol Invertible",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Invertible.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Invertible.swift\" line=\"9\" column=\"17\"><Name>Invertible<\/Name><USR>s:7Algebra10InvertibleP<\/USR><Declaration>public protocol Invertible<\/Declaration><CommentParts><Abstract><Para>Interface for types which have an inverse.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 9,
        "key.doc.name" : "Invertible",
        "key.doc.type" : "Class",
        "key.doclength" : 47,
        "key.docoffset" : 81,
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Invertible.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Invertible<\/decl.name><\/decl.protocol>",
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 53,
        "key.name" : "Invertible",
        "key.namelength" : 10,
        "key.nameoffset" : 144,
        "key.offset" : 135,
        "key.parsed_declaration" : "public protocol Invertible",
        "key.parsed_scope.end" : 11,
        "key.parsed_scope.start" : 9,
        "key.runtime_name" : "_TtP10Invertible10Invertible_",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>var inverse: <Type usr=\"s:7Algebra10InvertibleP4Selfxmfp\">Self<\/Type> { get }<\/Declaration>",
            "key.bodylength" : 5,
            "key.bodyoffset" : 180,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Invertible.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>inverse<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:7Algebra10InvertibleP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 25,
            "key.name" : "inverse",
            "key.namelength" : 7,
            "key.nameoffset" : 165,
            "key.offset" : 161,
            "key.parsed_declaration" : "var inverse: Self",
            "key.parsed_scope.end" : 10,
            "key.parsed_scope.start" : 10,
            "key.typename" : "Self",
            "key.typeusr" : "$SxD",
            "key.usr" : "s:7Algebra10InvertibleP7inversexvp"
          }
        ],
        "key.typename" : "Invertible.Protocol",
        "key.typeusr" : "$S7Algebra10Invertible_pmD",
        "key.usr" : "s:7Algebra10InvertibleP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Monoid.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 417,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol Monoid : <Type usr=\"s:7Algebra9SemigroupP\">Semigroup<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 222
          }
        ],
        "key.bodylength" : 158,
        "key.bodyoffset" : 257,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface defining objects with two methods:\n\n- `Identity` element\n- `Composition` operation (inherited from `Semigroup`).",
        "key.doc.declaration" : "public protocol Monoid : Semigroup",
        "key.doc.discussion" : [
          {
            "List-Bullet" : ""
          }
        ],
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Monoid.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Monoid.swift\" line=\"14\" column=\"17\"><Name>Monoid<\/Name><USR>s:7Algebra6MonoidP<\/USR><Declaration>public protocol Monoid : Semigroup<\/Declaration><CommentParts><Abstract><Para>Interface defining objects with two methods:<\/Para><\/Abstract><Discussion><List-Bullet><Item><Para><codeVoice>Identity<\/codeVoice> element<\/Para><\/Item><Item><Para><codeVoice>Composition<\/codeVoice> operation (inherited from <codeVoice>Semigroup<\/codeVoice>).<\/Para><\/Item><\/List-Bullet><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 14,
        "key.doc.name" : "Monoid",
        "key.doc.type" : "Class",
        "key.doclength" : 142,
        "key.docoffset" : 80,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 9,
            "key.offset" : 246
          }
        ],
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Monoid.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Monoid<\/decl.name> : <ref.protocol usr=\"s:7Algebra9SemigroupP\">Semigroup<\/ref.protocol><\/decl.protocol>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Semigroup"
          }
        ],
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 187,
        "key.name" : "Monoid",
        "key.namelength" : 6,
        "key.nameoffset" : 238,
        "key.offset" : 229,
        "key.parsed_declaration" : "public protocol Monoid: Semigroup",
        "key.parsed_scope.end" : 23,
        "key.parsed_scope.start" : 14,
        "key.runtime_name" : "_TtP6Monoid6Monoid_",
        "key.substructure" : [
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 23,
            "key.name" : "MARK: - Type Properties",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 266
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>static var identity: <Type usr=\"s:7Algebra6MonoidP4Selfxmfp\">Self<\/Type> { get }<\/Declaration>",
            "key.bodylength" : 5,
            "key.bodyoffset" : 408,
            "key.doc.column" : 16,
            "key.doc.comment" : "Identity of `Monoid`.\n\n    monoid <> identity = monoid",
            "key.doc.declaration" : "static var identity: Self { get }",
            "key.doc.discussion" : [
              {
                "CodeListing" : ""
              }
            ],
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Monoid.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Monoid.swift\" line=\"22\" column=\"16\"><Name>identity<\/Name><USR>s:7Algebra6MonoidP8identityxvpZ<\/USR><Declaration>static var identity: Self { get }<\/Declaration><CommentParts><Abstract><Para>Identity of <codeVoice>Monoid<\/codeVoice>.<\/Para><\/Abstract><Discussion><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[monoid <> identity = monoid]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><\/Discussion><\/CommentParts><\/Other>",
            "key.doc.line" : 22,
            "key.doc.name" : "identity",
            "key.doc.type" : "Other",
            "key.doclength" : 82,
            "key.docoffset" : 295,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Monoid.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>identity<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:7Algebra6MonoidP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.static>",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 33,
            "key.name" : "identity",
            "key.namelength" : 8,
            "key.nameoffset" : 392,
            "key.offset" : 381,
            "key.parsed_declaration" : "static var identity: Self",
            "key.parsed_scope.end" : 22,
            "key.parsed_scope.start" : 22,
            "key.typename" : "Self",
            "key.typeusr" : "$SxD",
            "key.usr" : "s:7Algebra6MonoidP8identityxvpZ"
          }
        ],
        "key.typename" : "Monoid.Protocol",
        "key.typeusr" : "$S7Algebra6Monoid_pmD",
        "key.usr" : "s:7Algebra6MonoidP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 667,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol MonoidView : <Type usr=\"s:7Algebra6MonoidP\">Monoid<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 159
          }
        ],
        "key.bodylength" : 470,
        "key.bodyoffset" : 195,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface defining monoidal views of objects.\n\nSome types can be",
        "key.doc.declaration" : "public protocol MonoidView : Monoid",
        "key.doc.discussion" : [
          {
            "Para" : "Some types can be"
          }
        ],
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift\" line=\"12\" column=\"17\"><Name>MonoidView<\/Name><USR>s:7Algebra10MonoidViewP<\/USR><Declaration>public protocol MonoidView : Monoid<\/Declaration><CommentParts><Abstract><Para>Interface defining monoidal views of objects.<\/Para><\/Abstract><Discussion><Para>Some types can be<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 12,
        "key.doc.name" : "MonoidView",
        "key.doc.type" : "Class",
        "key.doclength" : 76,
        "key.docoffset" : 83,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 6,
            "key.offset" : 187
          }
        ],
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>MonoidView<\/decl.name> : <ref.protocol usr=\"s:7Algebra6MonoidP\">Monoid<\/ref.protocol><\/decl.protocol>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Monoid"
          }
        ],
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 500,
        "key.name" : "MonoidView",
        "key.namelength" : 10,
        "key.nameoffset" : 175,
        "key.offset" : 166,
        "key.parsed_declaration" : "public protocol MonoidView: Monoid",
        "key.parsed_scope.end" : 36,
        "key.parsed_scope.start" : 12,
        "key.runtime_name" : "_TtP10MonoidView10MonoidView_",
        "key.substructure" : [
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 24,
            "key.name" : "MARK: - Associated Types",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 204
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>associatedtype Value<\/Declaration>",
            "key.doc.column" : 20,
            "key.doc.comment" : "Type of the value wrapped by `Monoid`.",
            "key.doc.declaration" : "associatedtype Value",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift\" line=\"17\" column=\"20\"><Name>Value<\/Name><USR>s:7Algebra10MonoidViewP5ValueQa<\/USR><Declaration>associatedtype Value<\/Declaration><CommentParts><Abstract><Para>Type of the value wrapped by <codeVoice>Monoid<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 17,
            "key.doc.name" : "Value",
            "key.doc.type" : "Other",
            "key.doclength" : 43,
            "key.docoffset" : 234,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
            "key.fully_annotated_decl" : "<decl.associatedtype><syntaxtype.keyword>associatedtype<\/syntaxtype.keyword> <decl.name>Value<\/decl.name><\/decl.associatedtype>",
            "key.kind" : "source.lang.swift.decl.associatedtype",
            "key.length" : 20,
            "key.name" : "Value",
            "key.namelength" : 5,
            "key.nameoffset" : 296,
            "key.offset" : 281,
            "key.parsed_declaration" : "associatedtype Value",
            "key.parsed_scope.end" : 17,
            "key.parsed_scope.start" : 17,
            "key.typename" : "Self.Value.Type",
            "key.typeusr" : "$S5Value7Algebra10MonoidViewPQzmD",
            "key.usr" : "s:7Algebra10MonoidViewP5ValueQa"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 23,
            "key.name" : "MARK: - Type Properties",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 310
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>static var identity: <Type usr=\"s:7Algebra10MonoidViewP4Selfxmfp\">Self<\/Type> { get }<\/Declaration>",
            "key.bodylength" : 5,
            "key.bodyoffset" : 452,
            "key.doc.column" : 16,
            "key.doc.comment" : "Identity of `Monoid`.\n\n    monoid <> identity = monoid",
            "key.doc.declaration" : "static var identity: Self { get }",
            "key.doc.discussion" : [
              {
                "CodeListing" : ""
              }
            ],
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift\" line=\"25\" column=\"16\"><Name>identity<\/Name><USR>s:7Algebra10MonoidViewP8identityxvpZ<\/USR><Declaration>static var identity: Self { get }<\/Declaration><CommentParts><Abstract><Para>Identity of <codeVoice>Monoid<\/codeVoice>.<\/Para><\/Abstract><Discussion><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[monoid <> identity = monoid]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><\/Discussion><\/CommentParts><\/Other>",
            "key.doc.line" : 25,
            "key.doc.name" : "identity",
            "key.doc.type" : "Other",
            "key.doclength" : 82,
            "key.docoffset" : 339,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>identity<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:7Algebra10MonoidViewP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.static>",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 33,
            "key.name" : "identity",
            "key.namelength" : 8,
            "key.nameoffset" : 436,
            "key.offset" : 425,
            "key.parsed_declaration" : "static var identity: Self",
            "key.parsed_scope.end" : 25,
            "key.parsed_scope.start" : 25,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra6MonoidP8identityxvpZ\">identity<\/RelatedName>"
              }
            ],
            "key.typename" : "Self",
            "key.typeusr" : "$SxD",
            "key.usr" : "s:7Algebra10MonoidViewP8identityxvpZ"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 27,
            "key.name" : "MARK: - Instance Properties",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 467
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>var value: <Type usr=\"s:7Algebra10MonoidViewP5ValueQa\">Value<\/Type> { get }<\/Declaration>",
            "key.bodylength" : 5,
            "key.bodyoffset" : 553,
            "key.doc.column" : 9,
            "key.doc.comment" : "Value wrapped by `Monoid`.",
            "key.doc.declaration" : "var value: Value { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift\" line=\"30\" column=\"9\"><Name>value<\/Name><USR>s:7Algebra10MonoidViewP5value5ValueQzvp<\/USR><Declaration>var value: Value { get }<\/Declaration><CommentParts><Abstract><Para>Value wrapped by <codeVoice>Monoid<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 30,
            "key.doc.name" : "value",
            "key.doc.type" : "Other",
            "key.doclength" : 31,
            "key.docoffset" : 500,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>value<\/decl.name>: <decl.var.type><ref.associatedtype usr=\"s:7Algebra10MonoidViewP5ValueQa\">Value<\/ref.associatedtype><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 24,
            "key.name" : "value",
            "key.namelength" : 5,
            "key.nameoffset" : 539,
            "key.offset" : 535,
            "key.parsed_declaration" : "var value: Value",
            "key.parsed_scope.end" : 30,
            "key.parsed_scope.start" : 30,
            "key.typename" : "Self.Value",
            "key.typeusr" : "$S5Value7Algebra10MonoidViewPQzD",
            "key.usr" : "s:7Algebra10MonoidViewP5value5ValueQzvp"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 20,
            "key.name" : "MARK: - Initializers",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 568
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>init(_ value: <Type usr=\"s:7Algebra10MonoidViewP5ValueQa\">Value<\/Type>)<\/Declaration>",
            "key.doc.column" : 5,
            "key.doc.comment" : "Creates a `Monoid` with the given `value.",
            "key.doc.declaration" : "init(_ value: Value)",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift\" line=\"35\" column=\"5\"><Name>init(_:)<\/Name><USR>s:7Algebra10MonoidViewPyx5ValueQzcfc<\/USR><Declaration>init(_ value: Value)<\/Declaration><CommentParts><Abstract><Para>Creates a <codeVoice>Monoid<\/codeVoice> with the given `value.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 35,
            "key.doc.name" : "init(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 46,
            "key.docoffset" : 594,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MonoidView.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>value<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.associatedtype usr=\"s:7Algebra10MonoidViewP5ValueQa\">Value<\/ref.associatedtype><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 20,
            "key.name" : "init(_:)",
            "key.namelength" : 20,
            "key.nameoffset" : 644,
            "key.offset" : 644,
            "key.parsed_declaration" : "init(_ value: Value)",
            "key.parsed_scope.end" : 35,
            "key.parsed_scope.start" : 35,
            "key.substructure" : [

            ],
            "key.typename" : "<Self where Self : MonoidView> (Self.Type) -> (Self.Value) -> Self",
            "key.typeusr" : "$Syx5ValueQzcD",
            "key.usr" : "s:7Algebra10MonoidViewPyx5ValueQzcfc"
          }
        ],
        "key.typename" : "MonoidView.Protocol",
        "key.typeusr" : "$S7Algebra10MonoidView_pmD",
        "key.usr" : "s:7Algebra10MonoidViewP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Multiplicative.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 220,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol Multiplicative : <Type usr=\"s:7Algebra23MultiplicativeSemigroupP\">MultiplicativeSemigroup<\/Type>, <Type usr=\"s:7Algebra3OneP\">One<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 155
          }
        ],
        "key.bodylength" : 1,
        "key.bodyoffset" : 217,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface for types which can be viewed as an `Product` monoid.",
        "key.doc.declaration" : "public protocol Multiplicative : MultiplicativeSemigroup, One",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Multiplicative.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Multiplicative.swift\" line=\"10\" column=\"17\"><Name>Multiplicative<\/Name><USR>s:7Algebra14MultiplicativeP<\/USR><Declaration>public protocol Multiplicative : MultiplicativeSemigroup, One<\/Declaration><CommentParts><Abstract><Para>Interface for types which can be viewed as an <codeVoice>Product<\/codeVoice> monoid.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "Multiplicative",
        "key.doc.type" : "Class",
        "key.doclength" : 68,
        "key.docoffset" : 87,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 3,
            "key.offset" : 187
          },
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 23,
            "key.offset" : 192
          }
        ],
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Multiplicative.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Multiplicative<\/decl.name> : <ref.protocol usr=\"s:7Algebra23MultiplicativeSemigroupP\">MultiplicativeSemigroup<\/ref.protocol>, <ref.protocol usr=\"s:7Algebra3OneP\">One<\/ref.protocol><\/decl.protocol>",
        "key.inheritedtypes" : [
          {
            "key.name" : "One"
          },
          {
            "key.name" : "MultiplicativeSemigroup"
          }
        ],
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 57,
        "key.name" : "Multiplicative",
        "key.namelength" : 14,
        "key.nameoffset" : 171,
        "key.offset" : 162,
        "key.parsed_declaration" : "public protocol Multiplicative: One, MultiplicativeSemigroup",
        "key.parsed_scope.end" : 10,
        "key.parsed_scope.start" : 10,
        "key.runtime_name" : "_TtP14Multiplicative14Multiplicative_",
        "key.typename" : "Multiplicative.Protocol",
        "key.typeusr" : "$S7Algebra14Multiplicative_pmD",
        "key.usr" : "s:7Algebra14MultiplicativeP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 295,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol MultiplicativeSemigroup<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 167
          }
        ],
        "key.bodylength" : 85,
        "key.bodyoffset" : 208,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface for semigroups with an multiplicative binary operation.",
        "key.doc.declaration" : "public protocol MultiplicativeSemigroup",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift\" line=\"10\" column=\"17\"><Name>MultiplicativeSemigroup<\/Name><USR>s:7Algebra23MultiplicativeSemigroupP<\/USR><Declaration>public protocol MultiplicativeSemigroup<\/Declaration><CommentParts><Abstract><Para>Interface for semigroups with an multiplicative binary operation.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "MultiplicativeSemigroup",
        "key.doc.type" : "Class",
        "key.doclength" : 70,
        "key.docoffset" : 97,
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>MultiplicativeSemigroup<\/decl.name><\/decl.protocol>",
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 120,
        "key.name" : "MultiplicativeSemigroup",
        "key.namelength" : 23,
        "key.nameoffset" : 183,
        "key.offset" : 174,
        "key.parsed_declaration" : "public protocol MultiplicativeSemigroup",
        "key.parsed_scope.end" : 14,
        "key.parsed_scope.start" : 10,
        "key.runtime_name" : "_TtP23MultiplicativeSemigroup23MultiplicativeSemigroup_",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>static func * (lhs: <Type usr=\"s:7Algebra23MultiplicativeSemigroupP4Selfxmfp\">Self<\/Type>, rhs: <Type usr=\"s:7Algebra23MultiplicativeSemigroupP4Selfxmfp\">Self<\/Type>) -&gt; <Type usr=\"s:7Algebra23MultiplicativeSemigroupP4Selfxmfp\">Self<\/Type><\/Declaration>",
            "key.doc.column" : 17,
            "key.doc.comment" : "Multiplicative operation.",
            "key.doc.declaration" : "static func * (lhs: Self, rhs: Self) -> Self",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift\" line=\"13\" column=\"17\"><Name>*(_:_:)<\/Name><USR>s:7Algebra23MultiplicativeSemigroupP1moiyxx_xtFZ<\/USR><Declaration>static func * (lhs: Self, rhs: Self) -&gt; Self<\/Declaration><CommentParts><Abstract><Para>Multiplicative operation.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 13,
            "key.doc.name" : "*(_:_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 30,
            "key.docoffset" : 214,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>* <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra23MultiplicativeSemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra23MultiplicativeSemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.generic_type_param usr=\"s:7Algebra23MultiplicativeSemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 44,
            "key.name" : "*(_:_:)",
            "key.namelength" : 24,
            "key.nameoffset" : 260,
            "key.offset" : 248,
            "key.parsed_declaration" : "static func * (lhs: Self, rhs: Self) -> Self",
            "key.parsed_scope.end" : 13,
            "key.parsed_scope.start" : 13,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh7AlgebraE1moiyShyxGAC_ACtFZ\">* (_: Set, _: Set) -&gt; Set<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SF1moiyxx_xtFZ\">* (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sf1moiyS2f_SftFZ\">* (_: Float, _: Float) -&gt; Float<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sd1moiyS2d_SdtFZ\">* (_: Double, _: Double) -&gt; Double<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7Float80V1moiyA2B_ABtFZ\">* (_: Float80, _: Float80) -&gt; Float80<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sj1moiyxx_xtFZ\">* (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sz1moiyxx_xtFZ\">* (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V1moiyA2B_ABtFZ\">* (_: UInt8, _: UInt8) -&gt; UInt8<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V1moiyA2B_ABtFZ\">* (_: Int8, _: Int8) -&gt; Int8<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V1moiyA2B_ABtFZ\">* (_: UInt16, _: UInt16) -&gt; UInt16<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V1moiyA2B_ABtFZ\">* (_: Int16, _: Int16) -&gt; Int16<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V1moiyA2B_ABtFZ\">* (_: UInt32, _: UInt32) -&gt; UInt32<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V1moiyA2B_ABtFZ\">* (_: Int32, _: Int32) -&gt; Int32<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V1moiyA2B_ABtFZ\">* (_: UInt64, _: UInt64) -&gt; UInt64<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V1moiyA2B_ABtFZ\">* (_: Int64, _: Int64) -&gt; Int64<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su1moiyS2u_SutFZ\">* (_: UInt, _: UInt) -&gt; UInt<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si1moiyS2i_SitFZ\">* (_: Int, _: Int) -&gt; Int<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:7Algebra23MultiplicativeSemigroupP4Selfxmfp\">Self<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/MultiplicativeSemigroup.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra23MultiplicativeSemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 263,
                "key.parent_loc" : 260,
                "key.parsed_declaration" : "static func * (lhs: Self, rhs: Self) -> Self",
                "key.parsed_scope.end" : 13,
                "key.parsed_scope.start" : 13,
                "key.typename" : "Self",
                "key.typeusr" : "$SxD",
                "key.usr" : "s:7Algebra23MultiplicativeSemigroupP1moiyxx_xtFZ3lhsL_xvp"
              }
            ],
            "key.typename" : "<Self where Self : MultiplicativeSemigroup> (Self.Type) -> (Self, Self) -> Self",
            "key.typeusr" : "$Syxx_xtcD",
            "key.usr" : "s:7Algebra23MultiplicativeSemigroupP1moiyxx_xtFZ"
          }
        ],
        "key.typename" : "MultiplicativeSemigroup.Protocol",
        "key.typeusr" : "$S7Algebra23MultiplicativeSemigroup_pmD",
        "key.usr" : "s:7Algebra23MultiplicativeSemigroupP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 223,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol One<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 132
          }
        ],
        "key.bodylength" : 68,
        "key.bodyoffset" : 153,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface for types with a `one` identity element.",
        "key.doc.declaration" : "public protocol One",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift\" line=\"10\" column=\"17\"><Name>One<\/Name><USR>s:7Algebra3OneP<\/USR><Declaration>public protocol One<\/Declaration><CommentParts><Abstract><Para>Interface for types with a <codeVoice>one<\/codeVoice> identity element.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "One",
        "key.doc.type" : "Class",
        "key.doclength" : 55,
        "key.docoffset" : 77,
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>One<\/decl.name><\/decl.protocol>",
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 83,
        "key.name" : "One",
        "key.namelength" : 3,
        "key.nameoffset" : 148,
        "key.offset" : 139,
        "key.parsed_declaration" : "public protocol One",
        "key.parsed_scope.end" : 14,
        "key.parsed_scope.start" : 10,
        "key.runtime_name" : "_TtP3One3One_",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>static var one: <Type usr=\"s:7Algebra3OneP4Selfxmfp\">Self<\/Type> { get }<\/Declaration>",
            "key.bodylength" : 5,
            "key.bodyoffset" : 214,
            "key.doc.column" : 16,
            "key.doc.comment" : "Multiplicative identity.",
            "key.doc.declaration" : "static var one: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift\" line=\"13\" column=\"16\"><Name>one<\/Name><USR>s:7Algebra3OneP3onexvpZ<\/USR><Declaration>static var one: Self { get }<\/Declaration><CommentParts><Abstract><Para>Multiplicative identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "one",
            "key.doc.type" : "Other",
            "key.doclength" : 29,
            "key.docoffset" : 159,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/One.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>one<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:7Algebra3OneP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.static>",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 28,
            "key.name" : "one",
            "key.namelength" : 3,
            "key.nameoffset" : 203,
            "key.offset" : 192,
            "key.parsed_declaration" : "static var one: Self",
            "key.parsed_scope.end" : 13,
            "key.parsed_scope.start" : 13,
            "key.typename" : "Self",
            "key.typeusr" : "$SxD",
            "key.usr" : "s:7Algebra3OneP3onexvpZ"
          }
        ],
        "key.typename" : "One.Protocol",
        "key.typeusr" : "$S7Algebra3One_pmD",
        "key.usr" : "s:7Algebra3OneP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 1043,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public struct Product&lt;T&gt; : <Type usr=\"s:7Algebra10MonoidViewP\">MonoidView<\/Type> where T : <Type usr=\"s:7Algebra14MultiplicativeP\">Multiplicative<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 152
          }
        ],
        "key.bodylength" : 672,
        "key.bodyoffset" : 207,
        "key.doc.column" : 15,
        "key.doc.comment" : "Multiplicative monoidal view of a `Multiplicative`-conforming type.",
        "key.doc.declaration" : "public struct Product<T> : MonoidView where T : Multiplicative",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift\" line=\"10\" column=\"15\"><Name>Product<\/Name><USR>s:7Algebra7ProductV<\/USR><Declaration>public struct Product&lt;T&gt; : MonoidView where T : Multiplicative<\/Declaration><CommentParts><Abstract><Para>Multiplicative monoidal view of a <codeVoice>Multiplicative<\/codeVoice>-conforming type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "Product",
        "key.doc.type" : "Class",
        "key.doclength" : 72,
        "key.docoffset" : 80,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 10,
            "key.offset" : 195
          }
        ],
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Product<\/decl.name>&lt;<decl.generic_type_param usr=\"s:7Algebra7ProductV1Txmfp\"><decl.generic_type_param.name>T<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : <ref.protocol usr=\"s:7Algebra10MonoidViewP\">MonoidView<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>T : <ref.protocol usr=\"s:7Algebra14MultiplicativeP\">Multiplicative<\/ref.protocol><\/decl.generic_type_requirement><\/decl.struct>",
        "key.inheritedtypes" : [
          {
            "key.name" : "MonoidView"
          }
        ],
        "key.kind" : "source.lang.swift.decl.struct",
        "key.length" : 721,
        "key.name" : "Product",
        "key.namelength" : 7,
        "key.nameoffset" : 166,
        "key.offset" : 159,
        "key.parsed_declaration" : "public struct Product <T: Multiplicative>: MonoidView",
        "key.parsed_scope.end" : 37,
        "key.parsed_scope.start" : 10,
        "key.substructure" : [
          {
            "key.annotated_decl" : "<Declaration>T : <Type usr=\"s:7Algebra14MultiplicativeP\">Multiplicative<\/Type><\/Declaration>",
            "key.elements" : [
              {
                "key.kind" : "source.lang.swift.structure.elem.typeref",
                "key.length" : 14,
                "key.offset" : 178
              }
            ],
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>T<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:7Algebra14MultiplicativeP\">Multiplicative<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
            "key.inheritedtypes" : [
              {
                "key.name" : "Multiplicative"
              }
            ],
            "key.kind" : "source.lang.swift.decl.generic_type_param",
            "key.length" : 17,
            "key.name" : "T",
            "key.namelength" : 1,
            "key.nameoffset" : 175,
            "key.offset" : 175,
            "key.parsed_declaration" : "public struct Product <T: Multiplicative>: MonoidView",
            "key.parsed_scope.end" : 10,
            "key.parsed_scope.start" : 10,
            "key.typename" : "T.Type",
            "key.typeusr" : "$SxmD",
            "key.usr" : "s:7Algebra7ProductV1Txmfp"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 23,
            "key.name" : "MARK: - Type Properties",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 216
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static var identity: <Type usr=\"s:7Algebra7ProductV\">Product<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 329
              }
            ],
            "key.bodylength" : 35,
            "key.bodyoffset" : 366,
            "key.doc.column" : 23,
            "key.doc.comment" : "- Returns: The multiplicative identity wrapped in a `MultiplicativeMonoid`.",
            "key.doc.declaration" : "public static var identity: Product { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift\" line=\"15\" column=\"23\"><Name>identity<\/Name><USR>s:7Algebra7ProductV8identityACyxGvpZ<\/USR><Declaration>public static var identity: Product { get }<\/Declaration><CommentParts><ResultDiscussion><Para>The multiplicative identity wrapped in a <codeVoice>MultiplicativeMonoid<\/codeVoice>.<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 15,
            "key.doc.name" : "identity",
            "key.doc.result_discussion" : [
              {
                "Para" : "The multiplicative identity wrapped in a `MultiplicativeMonoid`."
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 80,
            "key.docoffset" : 245,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>identity<\/decl.name>: <decl.var.type><ref.struct usr=\"s:7Algebra7ProductV\">Product<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.static>",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 66,
            "key.name" : "identity",
            "key.namelength" : 8,
            "key.nameoffset" : 347,
            "key.offset" : 336,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra10MonoidViewP8identityxvpZ"
              },
              {
                "key.usr" : "s:7Algebra6MonoidP8identityxvpZ"
              }
            ],
            "key.parsed_declaration" : "public static var identity: Product",
            "key.parsed_scope.end" : 17,
            "key.parsed_scope.start" : 15,
            "key.typename" : "Product<T>",
            "key.typeusr" : "$S7Algebra7ProductVyxGD",
            "key.usr" : "s:7Algebra7ProductV8identityACyxGvpZ"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 20,
            "key.name" : "MARK: - Type Methods",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 411
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func &lt;&gt; (lhs: <Type usr=\"s:7Algebra7ProductV\">Product<\/Type>, rhs: <Type usr=\"s:7Algebra7ProductV\">Product<\/Type>) -&gt; <Type usr=\"s:7Algebra7ProductV\">Product<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 497
              }
            ],
            "key.bodylength" : 51,
            "key.bodyoffset" : 560,
            "key.doc.column" : 24,
            "key.doc.comment" : "- Returns: The composition of the two given values.",
            "key.doc.declaration" : "public static func <> (lhs: Product, rhs: Product) -> Product",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift\" line=\"22\" column=\"24\"><Name>&lt;&gt;(_:_:)<\/Name><USR>s:7Algebra7ProductV2lgoiyACyxGAE_AEtFZ<\/USR><Declaration>public static func &lt;&gt; (lhs: Product, rhs: Product) -&gt; Product<\/Declaration><CommentParts><ResultDiscussion><Para>The composition of the two given values.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 22,
            "key.doc.name" : "<>(_:_:)",
            "key.doc.result_discussion" : [
              {
                "Para" : "The composition of the two given values."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 56,
            "key.docoffset" : 437,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>&lt;&gt; <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:7Algebra7ProductV\">Product<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:7Algebra7ProductV\">Product<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:7Algebra7ProductV\">Product<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 108,
            "key.name" : "<>(_:_:)",
            "key.namelength" : 31,
            "key.nameoffset" : 516,
            "key.offset" : 504,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra9SemigroupP2lgoiyxx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func <> (lhs: Product, rhs: Product) -> Product",
            "key.parsed_scope.end" : 24,
            "key.parsed_scope.start" : 22,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra9SemigroupP2lgoiyxx_xtFZ\">&lt;&gt; (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra3SumV2lgoiyACyxGAE_AEtFZ\">&lt;&gt; (_: Sum, _: Sum) -&gt; Sum<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:7Algebra7ProductV\">Product<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:7Algebra7ProductV\">Product<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 520,
                "key.parent_loc" : 516,
                "key.parsed_declaration" : "public static func <> (lhs: Product, rhs: Product) -> Product",
                "key.parsed_scope.end" : 22,
                "key.parsed_scope.start" : 22,
                "key.typename" : "Product<T>",
                "key.typeusr" : "$S7Algebra7ProductVyxGD",
                "key.usr" : "s:7Algebra7ProductV2lgoiyACyxGAE_AEtFZ3lhsL_AEvp"
              }
            ],
            "key.typename" : "<T where T : Multiplicative> (Product<T>.Type) -> (Product<T>, Product<T>) -> Product<T>",
            "key.typeusr" : "$Sy7Algebra7ProductVyxGAD_ADtcD",
            "key.usr" : "s:7Algebra7ProductV2lgoiyACyxGAE_AEtFZ"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 27,
            "key.name" : "MARK: - Instance Properties",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 621
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public let value: <Type usr=\"s:7Algebra7ProductV1Txmfp\">T<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 701
              }
            ],
            "key.doc.column" : 16,
            "key.doc.comment" : "Value wrapped by `MultiplativeMonoid`.",
            "key.doc.declaration" : "public let value: T",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift\" line=\"29\" column=\"16\"><Name>value<\/Name><USR>s:7Algebra7ProductV5valuexvp<\/USR><Declaration>public let value: T<\/Declaration><CommentParts><Abstract><Para>Value wrapped by <codeVoice>MultiplativeMonoid<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 29,
            "key.doc.name" : "value",
            "key.doc.type" : "Other",
            "key.doclength" : 43,
            "key.docoffset" : 654,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>value<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:7Algebra7ProductV1Txmfp\">T<\/ref.generic_type_param><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 12,
            "key.name" : "value",
            "key.namelength" : 5,
            "key.nameoffset" : 712,
            "key.offset" : 708,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra10MonoidViewP5value5ValueQzvp"
              }
            ],
            "key.parsed_declaration" : "public let value: T",
            "key.parsed_scope.end" : 29,
            "key.parsed_scope.start" : 29,
            "key.typename" : "T",
            "key.typeusr" : "$SxD",
            "key.usr" : "s:7Algebra7ProductV5valuexvp"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 20,
            "key.name" : "MARK: - Initializers",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 729
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init(_ value: <Type usr=\"s:7Algebra7ProductV1Txmfp\">T<\/Type>)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 820
              }
            ],
            "key.bodylength" : 32,
            "key.bodyoffset" : 845,
            "key.doc.column" : 12,
            "key.doc.comment" : "Creates a `MultiplicativeMonoid` with the given `value.`",
            "key.doc.declaration" : "public init(_ value: T)",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift\" line=\"34\" column=\"12\"><Name>init(_:)<\/Name><USR>s:7Algebra7ProductVyACyxGxcfc<\/USR><Declaration>public init(_ value: T)<\/Declaration><CommentParts><Abstract><Para>Creates a <codeVoice>MultiplicativeMonoid<\/codeVoice> with the given <codeVoice>value.<\/codeVoice><\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 34,
            "key.doc.name" : "init(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 61,
            "key.docoffset" : 755,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>value<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra7ProductV1Txmfp\">T<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 51,
            "key.name" : "init(_:)",
            "key.namelength" : 16,
            "key.nameoffset" : 827,
            "key.offset" : 827,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra10MonoidViewPyx5ValueQzcfc"
              }
            ],
            "key.parsed_declaration" : "public init(_ value: T)",
            "key.parsed_scope.end" : 36,
            "key.parsed_scope.start" : 34,
            "key.substructure" : [

            ],
            "key.typename" : "<T where T : Multiplicative> (Product<T>.Type) -> (T) -> Product<T>",
            "key.typeusr" : "$Sy7Algebra7ProductVyxGxcD",
            "key.usr" : "s:7Algebra7ProductVyACyxGxcfc"
          }
        ],
        "key.typename" : "Product<T>.Type",
        "key.typeusr" : "$S7Algebra7ProductVyxGmD",
        "key.usr" : "s:7Algebra7ProductV"
      },
      {
        "key.annotated_decl" : "<Declaration>public protocol Multiplicative : <Type usr=\"s:7Algebra23MultiplicativeSemigroupP\">MultiplicativeSemigroup<\/Type>, <Type usr=\"s:7Algebra3OneP\">One<\/Type><\/Declaration>",
        "key.bodylength" : 133,
        "key.bodyoffset" : 908,
        "key.doc.column" : 17,
        "key.doc.declaration" : "public protocol Multiplicative : MultiplicativeSemigroup, One",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Multiplicative.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Multiplicative.swift\" line=\"10\" column=\"17\"><Name>Multiplicative<\/Name><USR>s:7Algebra14MultiplicativeP<\/USR><Declaration>public protocol Multiplicative : MultiplicativeSemigroup, One<\/Declaration><CommentParts><Abstract><Para>Interface for types which can be viewed as an <codeVoice>Product<\/codeVoice> monoid.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "Multiplicative",
        "key.doc.type" : "Class",
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Multiplicative.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Multiplicative<\/decl.name> : <ref.protocol usr=\"s:7Algebra23MultiplicativeSemigroupP\">MultiplicativeSemigroup<\/ref.protocol>, <ref.protocol usr=\"s:7Algebra3OneP\">One<\/ref.protocol><\/decl.protocol>",
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 160,
        "key.name" : "Multiplicative",
        "key.namelength" : 14,
        "key.nameoffset" : 892,
        "key.offset" : 882,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var product: <Type usr=\"s:7Algebra7ProductV\">Product<\/Type>&lt;<Type usr=\"s:7Algebra14MultiplicativePAAE4Selfxmfp\">Self<\/Type>&gt; { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 970
              }
            ],
            "key.bodylength" : 34,
            "key.bodyoffset" : 1005,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: A `Product` monoidal view of `self`.",
            "key.doc.declaration" : "public var product: Product<Self> { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift\" line=\"42\" column=\"16\"><Name>product<\/Name><USR>s:7Algebra14MultiplicativePAAE7productAA7ProductVyxGvp<\/USR><Declaration>public var product: Product&lt;Self&gt; { get }<\/Declaration><CommentParts><ResultDiscussion><Para>A <codeVoice>Product<\/codeVoice> monoidal view of <codeVoice>self<\/codeVoice>.<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 42,
            "key.doc.name" : "product",
            "key.doc.result_discussion" : [
              {
                "Para" : "A `Product` monoidal view of `self`."
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 52,
            "key.docoffset" : 914,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Product.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>product<\/decl.name>: <decl.var.type><ref.struct usr=\"s:7Algebra7ProductV\">Product<\/ref.struct>&lt;<ref.generic_type_param usr=\"s:7Algebra14MultiplicativePAAE4Selfxmfp\">Self<\/ref.generic_type_param>&gt;<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 63,
            "key.name" : "product",
            "key.namelength" : 7,
            "key.nameoffset" : 981,
            "key.offset" : 977,
            "key.parsed_declaration" : "public var product: Product<Self>",
            "key.parsed_scope.end" : 44,
            "key.parsed_scope.start" : 42,
            "key.typename" : "Product<Self>",
            "key.typeusr" : "$S7Algebra7ProductVyxGD",
            "key.usr" : "s:7Algebra14MultiplicativePAAE7productAA7ProductVyxGvp"
          }
        ],
        "key.typename" : "Multiplicative.Protocol",
        "key.typeusr" : "$S7Algebra14Multiplicative_pmD",
        "key.usr" : "s:7Algebra14MultiplicativeP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Semigroup.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 402,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol Semigroup<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 242
          }
        ],
        "key.bodylength" : 131,
        "key.bodyoffset" : 269,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface defining objects with a single property:\n\n- `Composition` operation.",
        "key.doc.declaration" : "public protocol Semigroup",
        "key.doc.discussion" : [
          {
            "List-Bullet" : ""
          }
        ],
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Semigroup.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Semigroup.swift\" line=\"16\" column=\"17\"><Name>Semigroup<\/Name><USR>s:7Algebra9SemigroupP<\/USR><Declaration>public protocol Semigroup<\/Declaration><CommentParts><Abstract><Para>Interface defining objects with a single property:<\/Para><\/Abstract><Discussion><List-Bullet><Item><Para><codeVoice>Composition<\/codeVoice> operation.<\/Para><\/Item><\/List-Bullet><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 16,
        "key.doc.name" : "Semigroup",
        "key.doc.type" : "Class",
        "key.doclength" : 94,
        "key.docoffset" : 148,
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Semigroup.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Semigroup<\/decl.name><\/decl.protocol>",
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 152,
        "key.name" : "Semigroup",
        "key.namelength" : 9,
        "key.nameoffset" : 258,
        "key.offset" : 249,
        "key.parsed_declaration" : "public protocol Semigroup",
        "key.parsed_scope.end" : 20,
        "key.parsed_scope.start" : 16,
        "key.runtime_name" : "_TtP9Semigroup9Semigroup_",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>static func &lt;&gt; (lhs: <Type usr=\"s:7Algebra9SemigroupP4Selfxmfp\">Self<\/Type>, rhs: <Type usr=\"s:7Algebra9SemigroupP4Selfxmfp\">Self<\/Type>) -&gt; <Type usr=\"s:7Algebra9SemigroupP4Selfxmfp\">Self<\/Type><\/Declaration>",
            "key.doc.column" : 17,
            "key.doc.comment" : "- Returns: Composition of two of the same `Semigroup` type values.",
            "key.doc.declaration" : "static func <> (lhs: Self, rhs: Self) -> Self",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Semigroup.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Semigroup.swift\" line=\"19\" column=\"17\"><Name>&lt;&gt;(_:_:)<\/Name><USR>s:7Algebra9SemigroupP2lgoiyxx_xtFZ<\/USR><Declaration>static func &lt;&gt; (lhs: Self, rhs: Self) -&gt; Self<\/Declaration><CommentParts><ResultDiscussion><Para>Composition of two of the same <codeVoice>Semigroup<\/codeVoice> type values.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 19,
            "key.doc.name" : "<>(_:_:)",
            "key.doc.result_discussion" : [
              {
                "Para" : "Composition of two of the same `Semigroup` type values."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 71,
            "key.docoffset" : 275,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Semigroup.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>&lt;&gt; <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra9SemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra9SemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.generic_type_param usr=\"s:7Algebra9SemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 49,
            "key.name" : "<>(_:_:)",
            "key.namelength" : 29,
            "key.nameoffset" : 362,
            "key.offset" : 350,
            "key.parsed_declaration" : "static func <> (_ lhs: Self, _ rhs: Self) -> Self",
            "key.parsed_scope.end" : 19,
            "key.parsed_scope.start" : 19,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra7ProductV2lgoiyACyxGAE_AEtFZ\">&lt;&gt; (_: Product, _: Product) -&gt; Product<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra3SumV2lgoiyACyxGAE_AEtFZ\">&lt;&gt; (_: Sum, _: Sum) -&gt; Sum<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:7Algebra9SemigroupP4Selfxmfp\">Self<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Semigroup.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra9SemigroupP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 368,
                "key.parsed_declaration" : "static func <> (_ lhs: Self, _ rhs: Self) -> Self",
                "key.parsed_scope.end" : 19,
                "key.parsed_scope.start" : 19,
                "key.typename" : "Self",
                "key.typeusr" : "$SxD",
                "key.usr" : "s:7Algebra9SemigroupP2lgoiyxx_xtFZ3lhsL_xvp"
              }
            ],
            "key.typename" : "<Self where Self : Semigroup> (Self.Type) -> (Self, Self) -> Self",
            "key.typeusr" : "$Syxx_xtcD",
            "key.usr" : "s:7Algebra9SemigroupP2lgoiyxx_xtFZ"
          }
        ],
        "key.typename" : "Semigroup.Protocol",
        "key.typeusr" : "$S7Algebra9Semigroup_pmD",
        "key.usr" : "s:7Algebra9SemigroupP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 956,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public struct Sum&lt;T&gt; : <Type usr=\"s:7Algebra10MonoidViewP\">MonoidView<\/Type> where T : <Type usr=\"s:7Algebra8AdditiveP\">Additive<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 142
          }
        ],
        "key.bodylength" : 627,
        "key.bodyoffset" : 187,
        "key.doc.column" : 15,
        "key.doc.comment" : "Multiplicative monoidal view of a `Additive`-conforming type.",
        "key.doc.declaration" : "public struct Sum<T> : MonoidView where T : Additive",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift\" line=\"10\" column=\"15\"><Name>Sum<\/Name><USR>s:7Algebra3SumV<\/USR><Declaration>public struct Sum&lt;T&gt; : MonoidView where T : Additive<\/Declaration><CommentParts><Abstract><Para>Multiplicative monoidal view of a <codeVoice>Additive<\/codeVoice>-conforming type.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "Sum",
        "key.doc.type" : "Class",
        "key.doclength" : 66,
        "key.docoffset" : 76,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 10,
            "key.offset" : 175
          }
        ],
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Sum<\/decl.name>&lt;<decl.generic_type_param usr=\"s:7Algebra3SumV1Txmfp\"><decl.generic_type_param.name>T<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : <ref.protocol usr=\"s:7Algebra10MonoidViewP\">MonoidView<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>T : <ref.protocol usr=\"s:7Algebra8AdditiveP\">Additive<\/ref.protocol><\/decl.generic_type_requirement><\/decl.struct>",
        "key.inheritedtypes" : [
          {
            "key.name" : "MonoidView"
          }
        ],
        "key.kind" : "source.lang.swift.decl.struct",
        "key.length" : 666,
        "key.name" : "Sum",
        "key.namelength" : 3,
        "key.nameoffset" : 156,
        "key.offset" : 149,
        "key.parsed_declaration" : "public struct Sum <T: Additive>: MonoidView",
        "key.parsed_scope.end" : 37,
        "key.parsed_scope.start" : 10,
        "key.substructure" : [
          {
            "key.annotated_decl" : "<Declaration>T : <Type usr=\"s:7Algebra8AdditiveP\">Additive<\/Type><\/Declaration>",
            "key.elements" : [
              {
                "key.kind" : "source.lang.swift.structure.elem.typeref",
                "key.length" : 8,
                "key.offset" : 164
              }
            ],
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>T<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:7Algebra8AdditiveP\">Additive<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
            "key.inheritedtypes" : [
              {
                "key.name" : "Additive"
              }
            ],
            "key.kind" : "source.lang.swift.decl.generic_type_param",
            "key.length" : 11,
            "key.name" : "T",
            "key.namelength" : 1,
            "key.nameoffset" : 161,
            "key.offset" : 161,
            "key.parsed_declaration" : "public struct Sum <T: Additive>: MonoidView",
            "key.parsed_scope.end" : 10,
            "key.parsed_scope.start" : 10,
            "key.typename" : "T.Type",
            "key.typeusr" : "$SxmD",
            "key.usr" : "s:7Algebra3SumV1Txmfp"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 23,
            "key.name" : "MARK: - Type Properties",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 196
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static var identity: <Type usr=\"s:7Algebra3SumV\">Sum<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 297
              }
            ],
            "key.bodylength" : 32,
            "key.bodyoffset" : 330,
            "key.doc.column" : 23,
            "key.doc.comment" : "- Returns: The additive identity wrapped in a `AdditiveMonoid`.",
            "key.doc.declaration" : "public static var identity: Sum { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift\" line=\"15\" column=\"23\"><Name>identity<\/Name><USR>s:7Algebra3SumV8identityACyxGvpZ<\/USR><Declaration>public static var identity: Sum { get }<\/Declaration><CommentParts><ResultDiscussion><Para>The additive identity wrapped in a <codeVoice>AdditiveMonoid<\/codeVoice>.<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 15,
            "key.doc.name" : "identity",
            "key.doc.result_discussion" : [
              {
                "Para" : "The additive identity wrapped in a `AdditiveMonoid`."
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 68,
            "key.docoffset" : 225,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>identity<\/decl.name>: <decl.var.type><ref.struct usr=\"s:7Algebra3SumV\">Sum<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.static>",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 59,
            "key.name" : "identity",
            "key.namelength" : 8,
            "key.nameoffset" : 315,
            "key.offset" : 304,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra10MonoidViewP8identityxvpZ"
              },
              {
                "key.usr" : "s:7Algebra6MonoidP8identityxvpZ"
              }
            ],
            "key.parsed_declaration" : "public static var identity: Sum",
            "key.parsed_scope.end" : 17,
            "key.parsed_scope.start" : 15,
            "key.typename" : "Sum<T>",
            "key.typeusr" : "$S7Algebra3SumVyxGD",
            "key.usr" : "s:7Algebra3SumV8identityACyxGvpZ"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 20,
            "key.name" : "MARK: - Type Methods",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 372
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func &lt;&gt; (lhs: <Type usr=\"s:7Algebra3SumV\">Sum<\/Type>, rhs: <Type usr=\"s:7Algebra3SumV\">Sum<\/Type>) -&gt; <Type usr=\"s:7Algebra3SumV\">Sum<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 458
              }
            ],
            "key.bodylength" : 47,
            "key.bodyoffset" : 509,
            "key.doc.column" : 24,
            "key.doc.comment" : "- Returns: The composition of the two given values.",
            "key.doc.declaration" : "public static func <> (lhs: Sum, rhs: Sum) -> Sum",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift\" line=\"22\" column=\"24\"><Name>&lt;&gt;(_:_:)<\/Name><USR>s:7Algebra3SumV2lgoiyACyxGAE_AEtFZ<\/USR><Declaration>public static func &lt;&gt; (lhs: Sum, rhs: Sum) -&gt; Sum<\/Declaration><CommentParts><ResultDiscussion><Para>The composition of the two given values.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 22,
            "key.doc.name" : "<>(_:_:)",
            "key.doc.result_discussion" : [
              {
                "Para" : "The composition of the two given values."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 56,
            "key.docoffset" : 398,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>&lt;&gt; <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:7Algebra3SumV\">Sum<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:7Algebra3SumV\">Sum<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:7Algebra3SumV\">Sum<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 92,
            "key.name" : "<>(_:_:)",
            "key.namelength" : 23,
            "key.nameoffset" : 477,
            "key.offset" : 465,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra9SemigroupP2lgoiyxx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func <> (lhs: Sum, rhs: Sum) -> Sum",
            "key.parsed_scope.end" : 24,
            "key.parsed_scope.start" : 22,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra7ProductV2lgoiyACyxGAE_AEtFZ\">&lt;&gt; (_: Product, _: Product) -&gt; Product<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:7Algebra9SemigroupP2lgoiyxx_xtFZ\">&lt;&gt; (_: Self, _: Self) -&gt; Self<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:7Algebra3SumV\">Sum<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:7Algebra3SumV\">Sum<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 481,
                "key.parent_loc" : 477,
                "key.parsed_declaration" : "public static func <> (lhs: Sum, rhs: Sum) -> Sum",
                "key.parsed_scope.end" : 22,
                "key.parsed_scope.start" : 22,
                "key.typename" : "Sum<T>",
                "key.typeusr" : "$S7Algebra3SumVyxGD",
                "key.usr" : "s:7Algebra3SumV2lgoiyACyxGAE_AEtFZ3lhsL_AEvp"
              }
            ],
            "key.typename" : "<T where T : Additive> (Sum<T>.Type) -> (Sum<T>, Sum<T>) -> Sum<T>",
            "key.typeusr" : "$Sy7Algebra3SumVyxGAD_ADtcD",
            "key.usr" : "s:7Algebra3SumV2lgoiyACyxGAE_AEtFZ"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 27,
            "key.name" : "MARK: - Instance Properties",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 566
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public let value: <Type usr=\"s:7Algebra3SumV1Txmfp\">T<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 642
              }
            ],
            "key.doc.column" : 16,
            "key.doc.comment" : "Value wrapped by `AdditiveMonoid`.",
            "key.doc.declaration" : "public let value: T",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift\" line=\"29\" column=\"16\"><Name>value<\/Name><USR>s:7Algebra3SumV5valuexvp<\/USR><Declaration>public let value: T<\/Declaration><CommentParts><Abstract><Para>Value wrapped by <codeVoice>AdditiveMonoid<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 29,
            "key.doc.name" : "value",
            "key.doc.type" : "Other",
            "key.doclength" : 39,
            "key.docoffset" : 599,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>value<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:7Algebra3SumV1Txmfp\">T<\/ref.generic_type_param><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 12,
            "key.name" : "value",
            "key.namelength" : 5,
            "key.nameoffset" : 653,
            "key.offset" : 649,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra10MonoidViewP5value5ValueQzvp"
              }
            ],
            "key.parsed_declaration" : "public let value: T",
            "key.parsed_scope.end" : 29,
            "key.parsed_scope.start" : 29,
            "key.typename" : "T",
            "key.typeusr" : "$SxD",
            "key.usr" : "s:7Algebra3SumV5valuexvp"
          },
          {
            "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
            "key.length" : 20,
            "key.name" : "MARK: - Initializers",
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 670
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init(_ value: <Type usr=\"s:7Algebra3SumV1Txmfp\">T<\/Type>)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 755
              }
            ],
            "key.bodylength" : 32,
            "key.bodyoffset" : 780,
            "key.doc.column" : 12,
            "key.doc.comment" : "Creates a `AdditiveMonoid` with the given `value.`",
            "key.doc.declaration" : "public init(_ value: T)",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift\" line=\"34\" column=\"12\"><Name>init(_:)<\/Name><USR>s:7Algebra3SumVyACyxGxcfc<\/USR><Declaration>public init(_ value: T)<\/Declaration><CommentParts><Abstract><Para>Creates a <codeVoice>AdditiveMonoid<\/codeVoice> with the given <codeVoice>value.<\/codeVoice><\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 34,
            "key.doc.name" : "init(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 55,
            "key.docoffset" : 696,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>value<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:7Algebra3SumV1Txmfp\">T<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 51,
            "key.name" : "init(_:)",
            "key.namelength" : 16,
            "key.nameoffset" : 762,
            "key.offset" : 762,
            "key.overrides" : [
              {
                "key.usr" : "s:7Algebra10MonoidViewPyx5ValueQzcfc"
              }
            ],
            "key.parsed_declaration" : "public init(_ value: T)",
            "key.parsed_scope.end" : 36,
            "key.parsed_scope.start" : 34,
            "key.substructure" : [

            ],
            "key.typename" : "<T where T : Additive> (Sum<T>.Type) -> (T) -> Sum<T>",
            "key.typeusr" : "$Sy7Algebra3SumVyxGxcD",
            "key.usr" : "s:7Algebra3SumVyACyxGxcfc"
          }
        ],
        "key.typename" : "Sum<T>.Type",
        "key.typeusr" : "$S7Algebra3SumVyxGmD",
        "key.usr" : "s:7Algebra3SumV"
      },
      {
        "key.annotated_decl" : "<Declaration>public protocol Additive : <Type usr=\"s:7Algebra17AdditiveSemigroupP\">AdditiveSemigroup<\/Type>, <Type usr=\"s:7Algebra4ZeroP\">Zero<\/Type><\/Declaration>",
        "key.bodylength" : 117,
        "key.bodyoffset" : 837,
        "key.doc.column" : 17,
        "key.doc.declaration" : "public protocol Additive : AdditiveSemigroup, Zero",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Additive.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Additive.swift\" line=\"10\" column=\"17\"><Name>Additive<\/Name><USR>s:7Algebra8AdditiveP<\/USR><Declaration>public protocol Additive : AdditiveSemigroup, Zero<\/Declaration><CommentParts><Abstract><Para>Interface for types which can be viewed as an <codeVoice>Sum<\/codeVoice> monoid.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "Additive",
        "key.doc.type" : "Class",
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Additive.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Additive<\/decl.name> : <ref.protocol usr=\"s:7Algebra17AdditiveSemigroupP\">AdditiveSemigroup<\/ref.protocol>, <ref.protocol usr=\"s:7Algebra4ZeroP\">Zero<\/ref.protocol><\/decl.protocol>",
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 138,
        "key.name" : "Additive",
        "key.namelength" : 8,
        "key.nameoffset" : 827,
        "key.offset" : 817,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var sum: <Type usr=\"s:7Algebra3SumV\">Sum<\/Type>&lt;<Type usr=\"s:7Algebra8AdditivePAAE4Selfxmfp\">Self<\/Type>&gt; { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 895
              }
            ],
            "key.bodylength" : 30,
            "key.bodyoffset" : 922,
            "key.doc.column" : 16,
            "key.doc.comment" : "- Returns: A `Sum` monoidal view of `self`.",
            "key.doc.declaration" : "public var sum: Sum<Self> { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift\" line=\"42\" column=\"16\"><Name>sum<\/Name><USR>s:7Algebra8AdditivePAAE3sumAA3SumVyxGvp<\/USR><Declaration>public var sum: Sum&lt;Self&gt; { get }<\/Declaration><CommentParts><ResultDiscussion><Para>A <codeVoice>Sum<\/codeVoice> monoidal view of <codeVoice>self<\/codeVoice>.<\/Para><\/ResultDiscussion><\/CommentParts><\/Other>",
            "key.doc.line" : 42,
            "key.doc.name" : "sum",
            "key.doc.result_discussion" : [
              {
                "Para" : "A `Sum` monoidal view of `self`."
              }
            ],
            "key.doc.type" : "Other",
            "key.doclength" : 48,
            "key.docoffset" : 843,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Sum.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>sum<\/decl.name>: <decl.var.type><ref.struct usr=\"s:7Algebra3SumV\">Sum<\/ref.struct>&lt;<ref.generic_type_param usr=\"s:7Algebra8AdditivePAAE4Selfxmfp\">Self<\/ref.generic_type_param>&gt;<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 51,
            "key.name" : "sum",
            "key.namelength" : 3,
            "key.nameoffset" : 906,
            "key.offset" : 902,
            "key.parsed_declaration" : "public var sum: Sum<Self>",
            "key.parsed_scope.end" : 44,
            "key.parsed_scope.start" : 42,
            "key.typename" : "Sum<Self>",
            "key.typeusr" : "$S7Algebra3SumVyxGD",
            "key.usr" : "s:7Algebra8AdditivePAAE3sumAA3SumVyxGvp"
          }
        ],
        "key.typename" : "Additive.Protocol",
        "key.typeusr" : "$S7Algebra8Additive_pmD",
        "key.usr" : "s:7Algebra8AdditiveP"
      }
    ]
  }
}, {
  "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 221,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public protocol Zero<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 134
          }
        ],
        "key.bodylength" : 63,
        "key.bodyoffset" : 156,
        "key.doc.column" : 17,
        "key.doc.comment" : "Interface for types with a `zero` identity element.",
        "key.doc.declaration" : "public protocol Zero",
        "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift\" line=\"10\" column=\"17\"><Name>Zero<\/Name><USR>s:7Algebra4ZeroP<\/USR><Declaration>public protocol Zero<\/Declaration><CommentParts><Abstract><Para>Interface for types with a <codeVoice>zero<\/codeVoice> identity element.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 10,
        "key.doc.name" : "Zero",
        "key.doc.type" : "Class",
        "key.doclength" : 56,
        "key.docoffset" : 78,
        "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Zero<\/decl.name><\/decl.protocol>",
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 79,
        "key.name" : "Zero",
        "key.namelength" : 4,
        "key.nameoffset" : 150,
        "key.offset" : 141,
        "key.parsed_declaration" : "public protocol Zero",
        "key.parsed_scope.end" : 14,
        "key.parsed_scope.start" : 10,
        "key.runtime_name" : "_TtP4Zero4Zero_",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>static var zero: <Type usr=\"s:7Algebra4ZeroP4Selfxmfp\">Self<\/Type> { get }<\/Declaration>",
            "key.bodylength" : 5,
            "key.bodyoffset" : 212,
            "key.doc.column" : 16,
            "key.doc.comment" : "Additive identity.",
            "key.doc.declaration" : "static var zero: Self { get }",
            "key.doc.file" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift\" line=\"13\" column=\"16\"><Name>zero<\/Name><USR>s:7Algebra4ZeroP4zeroxvpZ<\/USR><Declaration>static var zero: Self { get }<\/Declaration><CommentParts><Abstract><Para>Additive identity.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 13,
            "key.doc.name" : "zero",
            "key.doc.type" : "Other",
            "key.doclength" : 23,
            "key.docoffset" : 162,
            "key.filepath" : "\/Users\/BEAN\/dn-m\/Frameworks\/Structure\/Sources\/Algebra\/Zero.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>zero<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:7Algebra4ZeroP4Selfxmfp\">Self<\/ref.generic_type_param><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.static>",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 29,
            "key.name" : "zero",
            "key.namelength" : 4,
            "key.nameoffset" : 200,
            "key.offset" : 189,
            "key.parsed_declaration" : "static var zero: Self",
            "key.parsed_scope.end" : 13,
            "key.parsed_scope.start" : 13,
            "key.typename" : "Self",
            "key.typeusr" : "$SxD",
            "key.usr" : "s:7Algebra4ZeroP4zeroxvpZ"
          }
        ],
        "key.typename" : "Zero.Protocol",
        "key.typeusr" : "$S7Algebra4Zero_pmD",
        "key.usr" : "s:7Algebra4ZeroP"
      }
    ]
  }
}]
